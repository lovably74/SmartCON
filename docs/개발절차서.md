# SmartCON Lite 개발절차서 (통합본)

**문서 버전:** 3.0  
**작성일:** 2025년 12월 31일  
**최종 수정일:** 2025년 12월 31일  
**작성자:** Kiro AI Assistant  
**통합 기반 문서:** Development-Process v2.1, PRD v2.8, 실행계획 v4.0

---

## 1. 개발 철학 (Development Philosophy)

### 1.1 핵심 원칙
- **AI-Driven**: Cursor, Copilot 등 AI 도구를 적극 활용하여 보일러플레이트 코드를 최소화하고 비즈니스 로직에 집중합니다.
- **Iterative**: 완벽한 설계보다 빠른 프로토타이핑과 피드백 루프를 지향합니다.
- **Quality First**: TDD(Test Driven Development)를 원칙으로 하며, 모든 주요 기능은 테스트 코드를 동반해야 합니다.
- **Security by Design**: 보안을 설계 단계부터 고려하여 안전한 시스템을 구축합니다.

### 1.2 개발 가치
- **사용자 중심**: 실제 건설 현장의 요구사항을 반영한 실용적 개발
- **코드 품질**: 가독성, 유지보수성, 확장성을 고려한 고품질 코드 작성
- **협업**: 명확한 커뮤니케이션과 문서화를 통한 효율적 협업
- **지속적 개선**: 지속적인 리팩토링과 성능 최적화

---

## 2. 개발 환경 설정 (Development Environment)

### 2.1 필수 도구 설치
#### 2.1.1 개발 도구
- **IDE**: VS Code (프론트엔드) / IntelliJ IDEA (백엔드)
- **AI 도구**: Cursor, GitHub Copilot
- **버전 관리**: Git 2.30+
- **컨테이너**: Docker Desktop 4.0+
- **패키지 매니저**: Node.js 18+ (npm), Maven 3.8+

#### 2.1.2 런타임 환경
- **Java**: OpenJDK 17 (LTS)
- **Node.js**: 18.x (LTS)
- **데이터베이스**: MariaDB 10.11, Redis 7.x
- **클라우드**: AWS CLI (선택사항)

### 2.2 프로젝트 초기 설정
```bash
# 1. 저장소 클론
git clone https://github.com/company/smartcon-lite.git
cd smartcon-lite

# 2. 환경 변수 설정
cp .env.example .env
# .env 파일 편집하여 로컬 환경에 맞게 설정

# 3. Docker 컨테이너 실행
docker-compose up -d

# 4. 백엔드 의존성 설치 및 실행
cd backend
mvn clean install
mvn spring-boot:run

# 5. 프론트엔드 의존성 설치 및 실행
cd ../frontend
npm install
npm run dev
```

---

## 3. 개발 단계 및 프로세스 (Development Phases)

### 3.1 Phase 0: 프로젝트 셋업 (Environment Setup)
**목표**: 개발 환경 구축 및 프로토타입 고도화

**주요 작업**:
- 개발 환경 구축: IDE, Docker, Java 17, Node.js 18+
- 프로토타입 고도화: React + Shadcn/UI 기반의 와이어프레임 UI 완성
- CI/CD 파이프라인: Github Actions 기본 워크플로우(Build/Test) 설정

### 3.2 Phase 1: 코어 & 인증 (Core & Auth)
**목표**: 핵심 인프라 및 인증 시스템 구축

**주요 작업**:
- DB 설계 및 구축: Tenant, Company, User 등 핵심 엔티티 설계
- 인증 시스템: Spring Security + JWT 구현, 소셜 로그인 연동
- SaaS 온보딩: 구독 신청 및 테넌트 생성 로직 구현

### 3.3 Phase 2: 현장 및 작업 관리 (Site & Work)
**목표**: 현장 관리 및 작업 프로세스 구현

**주요 작업**:
- 현장 관리: 현장 개설, 공종 설정, 관리자 초대 기능
- 작업 프로세스: `작업 요청(Site) -> 수락(Team) -> 배정(Worker)` 플로우 구현
- 일보 시스템: 날씨 API 연동 및 일보 집계/승인 로직

### 3.4 Phase 3: 안면인식 및 출역 (FaceNet & Attendance)
**목표**: 안면인식 시스템 및 출역 관리 구현

**주요 작업**:
- 안면인식 파이프라인: 사진 등록, 임베딩 추출, 벡터 저장 로직
- 동기화 배치: Spring Batch를 이용한 Daily Sync Job 구현
- 출역 마감: 안면 인식 로그와 일보 대조 로직

### 3.5 Phase 4: 모바일 앱 및 부가기능 (Mobile & Extras)
**목표**: 모바일 앱 및 고급 기능 구현

**주요 작업**:
- Capacitor 연동: 카메라, GPS, Push Notification 네이티브 기능 연동
- 전자계약: PDF 생성 엔진(iText) 연동 및 서명/저장
- 정산/세무: 결제 모듈 및 홈택스 연동

---

## 4. 형상 관리 및 배포 전략 (Version Control & Deployment)

### 4.1 Branch Strategy (Git Flow Lite)
#### 4.1.1 브랜치 구조
- **main**: 프로덕션 배포 가능한 안정 버전
- **develop**: 개발 진행 중인 브랜치
- **feature/**: 개별 기능 개발 브랜치 (예: `feature/auth-login`)
- **hotfix/**: 긴급 수정 브랜치 (예: `hotfix/security-patch`)

#### 4.1.2 브랜치 네이밍 규칙
```
feature/{기능명}     # 예: feature/user-authentication
bugfix/{버그명}      # 예: bugfix/login-error
hotfix/{수정명}      # 예: hotfix/security-vulnerability
release/{버전}       # 예: release/v1.0.0
```

### 4.2 Commit Strategy
#### 4.2.1 Conventional Commits 준수
```
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
```

**타입 종류**:
- `feat`: 새로운 기능 추가
- `fix`: 버그 수정
- `docs`: 문서 수정
- `style`: 코드 포맷팅, 세미콜론 누락 등
- `refactor`: 코드 리팩토링
- `test`: 테스트 코드 추가/수정
- `chore`: 빌드 프로세스, 도구 설정 등

**예시**:
```
feat(auth): 소셜 로그인 기능 추가

카카오, 네이버 OAuth2 연동을 통한 소셜 로그인 기능을 구현했습니다.

Closes #123
```

### 4.3 배포 전략
#### 4.3.1 환경별 배포
- **Development**: develop 브랜치 자동 배포
- **Staging**: release 브랜치 수동 배포
- **Production**: main 브랜치 수동 배포 (승인 필요)

#### 4.3.2 배포 도구
- **Dev**: Docker Compose로 로컬/개발 서버 배포
- **Staging/Prod**: AWS ECS 또는 Kubernetes 배포

---

## 5. 코딩 표준 및 가이드라인 (Coding Standards)

### 5.1 Java 코딩 표준
#### 5.1.1 네이밍 규칙
```java
// 클래스명: PascalCase
public class UserService {
    
    // 메서드명: camelCase
    public User findUserById(Long userId) {
        // 변수명: camelCase
        String userName = user.getName();
        
        // 상수명: UPPER_SNAKE_CASE
        private static final String DEFAULT_ROLE = "USER";
    }
}
```

#### 5.1.2 패키지 구조
```
com.smartcon.domain.{domain}
├── controller/     # REST 컨트롤러
├── service/        # 비즈니스 로직
├── repository/     # 데이터 접근
├── entity/         # JPA 엔티티
└── dto/           # 데이터 전송 객체
```

### 5.2 TypeScript/React 코딩 표준
#### 5.2.1 컴포넌트 구조
```typescript
// 컴포넌트명: PascalCase
interface UserListProps {
  users: User[];
  onUserSelect: (user: User) => void;
}

export const UserList: React.FC<UserListProps> = ({ users, onUserSelect }) => {
  // 훅 사용
  const [selectedUser, setSelectedUser] = useState<User | null>(null);
  
  // 이벤트 핸들러: handle + 동작명
  const handleUserClick = (user: User) => {
    setSelectedUser(user);
    onUserSelect(user);
  };
  
  return (
    <div className="user-list">
      {users.map(user => (
        <UserCard 
          key={user.id}
          user={user}
          onClick={() => handleUserClick(user)}
        />
      ))}
    </div>
  );
};
```

---

## 6. 테스트 전략 (Testing Strategy)

### 6.1 테스트 피라미드
```
    /\
   /  \     E2E Tests (적음)
  /____\    
 /      \   Integration Tests (보통)
/________\  Unit Tests (많음)
```

### 6.2 백엔드 테스트
#### 6.2.1 단위 테스트 (JUnit 5)
```java
@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    
    @Mock
    private UserRepository userRepository;
    
    @InjectMocks
    private UserService userService;
    
    @Test
    @DisplayName("사용자 ID로 사용자를 조회할 수 있다")
    void findById_Success() {
        // Given
        Long userId = 1L;
        User expectedUser = User.builder()
            .id(userId)
            .name("홍길동")
            .email("hong@example.com")
            .build();
        
        when(userRepository.findById(userId)).thenReturn(Optional.of(expectedUser));
        
        // When
        User actualUser = userService.findById(userId);
        
        // Then
        assertThat(actualUser).isEqualTo(expectedUser);
        verify(userRepository).findById(userId);
    }
}
```

### 6.3 프론트엔드 테스트
#### 6.3.1 단위 테스트 (Vitest + React Testing Library)
```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import { describe, it, expect, vi } from 'vitest';
import { UserCard } from './UserCard';

describe('UserCard', () => {
  const mockUser = {
    id: 1,
    name: '홍길동',
    email: 'hong@example.com',
    role: 'WORKER' as const
  };

  it('사용자 정보를 올바르게 표시한다', () => {
    render(<UserCard user={mockUser} />);
    
    expect(screen.getByText('홍길동')).toBeInTheDocument();
    expect(screen.getByText('hong@example.com')).toBeInTheDocument();
  });
});
```

---

## 7. 보안 가이드라인 (Security Guidelines)

### 7.1 인증 및 인가
#### 7.1.1 JWT 토큰 관리
```java
@Component
public class JwtTokenProvider {
    
    private static final long ACCESS_TOKEN_VALIDITY = 15 * 60 * 1000; // 15분
    private static final long REFRESH_TOKEN_VALIDITY = 7 * 24 * 60 * 60 * 1000; // 7일
    
    public String generateAccessToken(Authentication authentication) {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        Date expiryDate = new Date(System.currentTimeMillis() + ACCESS_TOKEN_VALIDITY);
        
        return Jwts.builder()
                .setSubject(userPrincipal.getId().toString())
                .setIssuedAt(new Date())
                .setExpiration(expiryDate)
                .signWith(SignatureAlgorithm.HS512, jwtSecret)
                .compact();
    }
}
```

### 7.2 데이터 보호
#### 7.2.1 개인정보 암호화
```java
@Entity
public class User extends BaseTenantEntity {
    
    @Column(nullable = false)
    private String name;
    
    @Convert(converter = EncryptedStringConverter.class)
    @Column(name = "resident_number")
    private String residentNumber; // 주민번호 암호화
    
    @Convert(converter = EncryptedStringConverter.class)
    @Column(name = "account_number")
    private String accountNumber; // 계좌번호 암호화
}
```

---

## 8. 성능 최적화 가이드 (Performance Optimization)

### 8.1 데이터베이스 최적화
#### 8.1.1 인덱스 전략
```sql
-- 복합 인덱스 생성
CREATE INDEX idx_attendance_tenant_date ON attendance_logs(tenant_id, work_date);
CREATE INDEX idx_user_tenant_email ON users(tenant_id, email);

-- 부분 인덱스 (조건부 인덱스)
CREATE INDEX idx_active_users ON users(tenant_id) WHERE is_active = true;
```

### 8.2 캐싱 전략
#### 8.2.1 Redis 캐싱
```java
@Service
public class UserService {
    
    @Cacheable(value = "users", key = "#userId")
    public User findById(Long userId) {
        return userRepository.findById(userId)
            .orElseThrow(() -> new UserNotFoundException("사용자를 찾을 수 없습니다"));
    }
    
    @CacheEvict(value = "users", key = "#user.id")
    public User updateUser(User user) {
        return userRepository.save(user);
    }
}
```

---

## 9. 배포 및 운영 (Deployment & Operations)

### 9.1 CI/CD 파이프라인
#### 9.1.1 GitHub Actions 워크플로우
```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
      
      - name: Run backend tests
        run: |
          cd backend
          mvn clean test
```

### 9.2 Docker 컨테이너화
#### 9.2.1 백엔드 Dockerfile
```dockerfile
# backend/Dockerfile
FROM openjdk:17-jre-slim

WORKDIR /app

COPY target/smartcon-backend-*.jar app.jar

EXPOSE 8080

ENTRYPOINT ["java", "-jar", "app.jar"]
```

---

## 10. 결론 및 다음 단계

### 10.1 개발 프로세스 요약
SmartCON Lite 프로젝트의 개발 프로세스는 다음과 같은 핵심 원칙을 기반으로 합니다:

1. **품질 우선**: 테스트 주도 개발과 코드 리뷰를 통한 고품질 코드 작성
2. **보안 강화**: 설계 단계부터 보안을 고려한 안전한 시스템 구축
3. **성능 최적화**: 데이터베이스 최적화와 캐싱을 통한 고성능 시스템 구현
4. **지속적 개선**: CI/CD 파이프라인을 통한 지속적인 통합과 배포

### 10.2 성공 지표
- **코드 품질**: 테스트 커버리지 80% 이상, 코드 리뷰 100% 완료
- **보안**: 보안 취약점 0건, 개인정보 암호화 100% 적용
- **성능**: API 응답 시간 200ms 이하, 데이터베이스 쿼리 최적화 완료
- **배포**: 자동화된 CI/CD 파이프라인, 무중단 배포 구현

---

**문서 정보**  
- **버전**: 3.0
- **최종 업데이트**: 2025년 12월 31일
- **다음 리뷰**: 2026년 1월 14일
- **승인자**: 개발팀 리더 및 아키텍트 검토 필요