# SmartCON Lite 상세 기능명세서

**문서 버전:** 3.0  
**작성일:** 2025년 12월 23일  
**최종 수정일:** 2025년 12월 23일  
**작성자:** Kiro AI Assistant  
**기반 문서:** PRD v2.8, Functional-Specification v2.1, Platform-API-Specification v1.0

---

## 1. 문서 개요

본 문서는 SmartCON Lite SaaS 플랫폼의 상세 기능명세를 정의합니다. 
5단계 사용자 역할(슈퍼관리자, 본사관리자, 현장관리자, 팀장, 노무자)별 기능과 
멀티테넌트 아키텍처 기반의 시스템 요구사항을 포함합니다.

### 1.1 문서 목적
- 개발팀을 위한 상세 구현 가이드 제공
- 사용자 스토리 및 수용 기준 정의
- API 설계 및 데이터 모델 명세
- 테스트 시나리오 및 검증 기준 제시

### 1.2 적용 범위
- 웹 애플리케이션 (React + TypeScript)
- 모바일 웹앱 (Capacitor 기반 하이브리드)
- 백엔드 API (Spring Boot + MariaDB)
- 외부 연동 시스템 (FaceNet, 기상청, PG사, 홈택스)

---

## 2. 시스템 아키텍처 및 기술 스택

### 2.1 멀티테넌트 아키텍처
- **격리 방식**: Shared Database, Shared Schema with tenant_id
- **테넌트 식별**: JWT 토큰 내 tenant_id 포함
- **데이터 격리**: 모든 비즈니스 테이블에 tenant_id 컬럼 강제
- **파일 격리**: S3 경로에 tenant_id 포함 (s3://bucket/{tenant_id}/...)

### 2.2 기술 스택 상세
#### Frontend
- **Framework**: React 18.2+ with TypeScript 5.0+
- **Build Tool**: Vite 5.0+ (HMR, Tree-shaking)
- **UI Library**: Shadcn/UI + Tailwind CSS 3.4+
- **State Management**: 
  - Zustand 4.4+ (클라이언트 상태)
  - TanStack Query 5.0+ (서버 상태, 캐싱)
- **Routing**: Wouter 3.0+ (경량 라우터)
- **Mobile**: Capacitor 6.0+ (카메라, GPS, 푸시알림)

#### Backend
- **Language**: Java 17 LTS
- **Framework**: Spring Boot 3.3.x
- **Database**: MariaDB 10.11 with JPA/Hibernate 6.x
- **Security**: Spring Security 6.x + JWT + OAuth2
- **Batch**: Spring Batch 5.x (안면인식 동기화, 정산)
- **Build**: Maven 3.8+

#### Infrastructure
- **Container**: Docker + Docker Compose
- **Storage**: AWS S3 (파일, 이미지)
- **Cache**: Redis 7.x (세션, 임시데이터)
- **CI/CD**: GitHub Actions (권장)

---

## 3. 사용자 역할 및 권한 매트릭스

### 3.1 역할 정의
| 역할 코드 | 역할명 | 주요 책임 | 접근 플랫폼 |
|-----------|--------|-----------|-------------|
| ROLE_SUPER | 슈퍼관리자 | SaaS 플랫폼 운영, 테넌트 관리, 결제/정산 | Web Only |
| ROLE_HQ | 본사관리자 | 테넌트 관리, 현장 개설, 전사 통계 | Web Only |
| ROLE_SITE | 현장관리자 | 현장 운영, 작업 지시, 출역 마감 | Web + Mobile |
| ROLE_TEAM | 팀장 | 팀원 관리, 작업 수락, 일보 제출 | Mobile Only |
| ROLE_WORKER | 노무자 | 출역 조회, 전자계약 서명 | Mobile Only |
### 3.2 권한 매트릭스

| 기능 영역 | SUPER | HQ | SITE | TEAM | WORKER |
|-----------|-------|----|----- |------|--------|
| **테넌트 관리** | ✓ | - | - | - | - |
| **구독/결제 관리** | ✓ | ✓ | - | - | - |
| **현장 개설/관리** | ✓ | ✓ | - | - | - |
| **사용자 초대/승인** | ✓ | ✓ | ✓ | - | - |
| **작업 지시/배정** | - | - | ✓ | - | - |
| **작업 수락/거부** | - | - | - | ✓ | - |
| **출역 기록 조회** | ✓ | ✓ | ✓ | ✓ | ✓ |
| **출역 마감/승인** | - | - | ✓ | - | - |
| **공사일보 작성** | - | - | ✓ | ✓ | - |
| **전자계약 서명** | - | - | - | - | ✓ |
| **정산/급여 조회** | ✓ | ✓ | ✓ | ✓ | ✓ |
| **안면인식 등록** | - | - | - | - | ✓ |
| **시스템 설정** | ✓ | ✓ | - | - | - |

---

## 4. 인증 및 온보딩 프로세스

### 4.1 인트로 페이지 (/) 
#### 4.1.1 기능 요구사항
- **목적**: 서비스 소개 및 로그인 진입점 제공
- **주요 메시지**: 
  - 메인: "안전관리, 이제는 스마트하게!"
  - 서브: "본사와 현장관리까지 한 번에 업무 끝! 스마트콘 [SmartCON]"
- **구성 요소**:
  - 상단 네비게이션 메뉴 (PC)
  - 서비스 소개 섹션
  - 핵심 기능 소개
  - 요금제 안내
  - 문의/데모 신청 폼
  - 로그인 버튼 (CTA)

#### 4.1.2 상단 메뉴 (PC 전용)
- 비대면바우처 (배지 표시)
- 스마트콘 소개
- 스마트콘 핵심기능  
- 서비스요금
- 문의하기
- 로그인

#### 4.1.3 문의/데모 신청 폼
**필수 입력 필드:**
- 회사명 (required)
- 담당자 성함 (required)
- 직책 (optional)
- 연락처 (required, 휴대폰 형식 검증)
- 이메일 (required, 이메일 형식 검증)
- 문의내용 (required, textarea)

**동의 항목:**
- 개인정보 수집 및 이용 동의 (required)
- 마케팅 수집 및 활용 동의 (optional)

**보안 검증:**
- 로봇 방지 질문 (간단한 수학 문제)

**반응형 레이아웃:**
- Desktop: 2컬럼 (입력 필드 / 문의내용 분리)
- Mobile: 1컬럼 (세로 스택)

#### 4.1.4 사용자 스토리
```
AS A 건설업체 관계자
I WANT TO 서비스 소개를 보고 문의를 남길 수 있기를
SO THAT 우리 회사에 적합한 솔루션인지 확인할 수 있다

수용 기준:
- 서비스 핵심 가치가 명확히 전달되어야 함
- 문의 폼 제출 시 확인 메시지 표시
- 모바일에서도 모든 기능이 정상 작동해야 함
- 로딩 시간 3초 이내
```

### 4.2 로그인 방식 선택 (/login)
#### 4.2.1 기능 요구사항
- **본사 관리자 로그인**: 사업자번호 + 비밀번호 방식
- **소셜 로그인**: Kakao, Naver OAuth2 연동
- **UI 구성**: 
  - 로그인 방식 선택 카드 (2개)
  - 각 방식별 설명 텍스트
  - 뒤로가기 버튼 (인트로 페이지로)

#### 4.2.2 사용자 스토리
```
AS A 사용자
I WANT TO 내 역할에 맞는 로그인 방식을 선택할 수 있기를
SO THAT 간편하고 안전하게 로그인할 수 있다

수용 기준:
- 본사 관리자와 현장 사용자 구분이 명확해야 함
- 각 로그인 방식의 장점이 설명되어야 함
- 선택 후 해당 로그인 페이지로 즉시 이동
```

### 4.3 본사 관리자 로그인 (/login/hq)
#### 4.3.1 기능 요구사항
- **인증 방식**: 사업자번호(ID) + 비밀번호
- **입력 검증**:
  - 사업자번호: 10자리 숫자, 하이픈 자동 삽입
  - 비밀번호: 8자 이상, 영문+숫자+특수문자 조합
- **보안 기능**:
  - 5회 실패 시 계정 잠금 (30분)
  - 로그인 시도 로그 기록
  - HTTPS 강제

#### 4.3.2 사용자 스토리
```
AS A 본사 관리자
I WANT TO 사업자번호와 비밀번호로 로그인할 수 있기를
SO THAT 회사의 전체 현장을 관리할 수 있다

수용 기준:
- 사업자번호 형식 자동 검증 (123-45-67890)
- 로그인 실패 시 명확한 오류 메시지
- 로그인 성공 시 HQ 대시보드로 이동
- 비밀번호 찾기 기능 제공
```
### 4.4 소셜 로그인 (/login/social)
#### 4.4.1 기능 요구사항
- **지원 플랫폼**: Kakao, Naver OAuth2
- **인증 플로우**:
  1. 소셜 플랫폼 선택
  2. OAuth2 인증 페이지 리다이렉트
  3. 인증 성공 시 콜백 처리
  4. 신규 사용자: 추가 정보 입력 (이름, 연락처)
  5. 기존 사용자: 역할/현장 선택 후 대시보드 이동

#### 4.4.2 사용자 스토리
```
AS A 현장 관리자/팀장/노무자
I WANT TO 소셜 계정으로 간편하게 로그인할 수 있기를
SO THAT 복잡한 회원가입 없이 빠르게 서비스를 이용할 수 있다

수용 기준:
- Kakao, Naver 로그인 버튼 제공
- 소셜 로그인 실패 시 재시도 가능
- 신규 사용자 추가 정보 입력 폼 제공
- 개인정보 처리방침 동의 필수
```

### 4.5 역할/현장 선택
#### 4.5.1 기능 요구사항
- **다중 역할 지원**: 한 사용자가 여러 현장에서 다른 역할 수행 가능
- **현장 목록**: 사용자가 속한 현장 목록 표시
- **역할 표시**: 각 현장에서의 역할 배지 표시
- **최근 접속**: 마지막 선택한 현장/역할 우선 표시

#### 4.5.2 사용자 스토리
```
AS A 여러 현장에서 일하는 사용자
I WANT TO 현장과 역할을 선택할 수 있기를
SO THAT 해당 현장의 업무에 집중할 수 있다

수용 기준:
- 현장별 역할이 명확히 표시되어야 함
- 선택 후 해당 역할의 대시보드로 이동
- 현장 전환 기능 (헤더에서 접근 가능)
```

---

## 5. 슈퍼 관리자 (ROLE_SUPER) 기능 명세

### 5.1 테넌트 관리 (ADM-01)
#### 5.1.1 기능 개요
SaaS 플랫폼에 가입한 모든 고객사(테넌트)의 생명주기를 관리합니다.

#### 5.1.2 상세 기능
**[ADM-01-01] 테넌트 목록 조회**
- **경로**: `/super/tenants`
- **기능**: 
  - 전체 테넌트 목록 페이징 조회
  - 검색 필터: 회사명, 사업자번호, 상태, 가입일
  - 정렬: 가입일, 매출액, 사용자 수
- **표시 정보**:
  - 회사명, 사업자번호
  - 가입일, 구독 상태
  - 월 매출액, 활성 사용자 수
  - 현장 수, 마지막 접속일

**[ADM-01-02] 테넌트 상세 정보**
- **경로**: `/super/tenants/{tenantId}`
- **기능**:
  - 테넌트 기본 정보 조회/수정
  - 구독 이력 및 결제 내역
  - 사용량 통계 (현장 수, 사용자 수, 저장 용량)
  - 접속 로그 및 활동 내역

**[ADM-01-03] 테넌트 상태 관리**
- **상태 종류**: 
  - ACTIVE (정상 운영)
  - SUSPENDED (일시 중지)
  - TERMINATED (해지)
  - TRIAL (체험판)
- **상태 변경 사유**: 결제 실패, 약관 위반, 사용자 요청 등
- **자동 처리**: 결제 실패 시 7일 후 자동 중지

#### 5.1.3 사용자 스토리
```
AS A 슈퍼 관리자
I WANT TO 모든 고객사의 상태를 모니터링하고 관리할 수 있기를
SO THAT 플랫폼의 안정적인 운영을 보장할 수 있다

수용 기준:
- 테넌트 목록을 다양한 조건으로 필터링 가능
- 상태 변경 시 고객에게 자동 알림 발송
- 모든 변경 사항이 감사 로그에 기록됨
- 대시보드에서 핵심 지표 실시간 확인 가능
```

### 5.2 결제 및 정산 관리 (ADM-02)
#### 5.2.1 기능 개요
구독 결제 모니터링, 실패 건 처리, 매출 분석을 수행합니다.

#### 5.2.2 상세 기능
**[ADM-02-01] 결제 대시보드**
- **경로**: `/super/billing/dashboard`
- **KPI 지표**:
  - 월간 매출액 (MRR - Monthly Recurring Revenue)
  - 신규 가입 고객 수 (New Customers)
  - 해지 고객 수 (Churned Customers)
  - 결제 성공률 (Payment Success Rate)
- **차트**:
  - 월별 매출 추이
  - 요금제별 가입 현황
  - 결제 실패 원인 분석

**[ADM-02-02] 결제 실패 관리**
- **경로**: `/super/billing/failed-payments`
- **기능**:
  - 결제 실패 건 목록 조회
  - 실패 사유별 분류 (카드 한도, 정지, 만료 등)
  - 재결제 시도 (Retry) 수동/자동 실행
  - 고객 알림 발송 (SMS, 이메일)

**[ADM-02-03] 세금계산서 발행**
- **경로**: `/super/billing/tax-invoices`
- **자동 발행**: 매월 1일 전월 사용분 일괄 발행
- **홈택스 연동**: 국세청 전자세금계산서 시스템 연동
- **발행 상태**: 대기, 발행완료, 전송완료, 실패
- **재발행**: 실패 건에 대한 수동 재발행 기능

#### 5.2.3 사용자 스토리
```
AS A 슈퍼 관리자
I WANT TO 모든 결제와 정산을 자동화하고 모니터링할 수 있기를
SO THAT 매출 손실을 최소화하고 세무 처리를 정확히 할 수 있다

수용 기준:
- 결제 실패 시 즉시 알림 수신
- 세금계산서 자동 발행 및 전송
- 매출 데이터 실시간 대시보드 제공
- 결제 관련 모든 로그 추적 가능
```

### 5.3 시스템 모니터링 (ADM-03)
#### 5.3.1 기능 개요
플랫폼 전체의 성능, 사용량, 오류를 모니터링합니다.

#### 5.3.2 상세 기능
**[ADM-03-01] 시스템 대시보드**
- **서버 상태**: CPU, 메모리, 디스크 사용률
- **데이터베이스**: 연결 수, 쿼리 성능, 슬로우 쿼리
- **외부 API**: FaceNet, 기상청, PG사 연동 상태
- **사용량 통계**: 일일 활성 사용자, API 호출 수

**[ADM-03-02] 오류 모니터링**
- **에러 로그**: 시스템 오류 실시간 수집
- **알림 설정**: 임계치 초과 시 Slack/이메일 알림
- **성능 지표**: 응답 시간, 처리량, 오류율

#### 5.3.3 사용자 스토리
```
AS A 슈퍼 관리자
I WANT TO 시스템 상태를 실시간으로 모니터링할 수 있기를
SO THAT 장애를 사전에 예방하고 빠르게 대응할 수 있다

수용 기준:
- 시스템 지표 실시간 대시보드 제공
- 임계치 초과 시 즉시 알림
- 과거 데이터와 비교 분석 가능
- 장애 발생 시 원인 추적 가능
```
---

## 6. 본사 관리자 (ROLE_HQ) 기능 명세

### 6.1 회사 정보 관리 (HQ-01)
#### 6.1.1 기능 개요
테넌트(회사)의 기본 정보, 브랜딩, 표준 설정을 관리합니다.

#### 6.1.2 상세 기능
**[HQ-01-01] 회사 기본 정보**
- **경로**: `/hq/company/profile`
- **관리 항목**:
  - 회사명, 사업자등록번호
  - 대표자명, 업종, 업태
  - 주소 (본사, 사업장)
  - 연락처 (대표전화, 팩스)
- **첨부 파일**:
  - 회사 로고 (PNG, JPG, 최대 2MB)
  - 직인 이미지 (계약서 날인용)
  - 사업자등록증 사본

**[HQ-01-02] 구독 신청 및 관리**
- **경로**: `/hq/subscription`
- **신규 구독 신청**:
  - 요금제 선택 (Basic, Standard, Premium, Enterprise)
  - 예상 사용량 입력 (현장 수, 사용자 수)
  - 결제 수단 등록 (신용카드, 계좌이체)
  - 약관 동의 및 전자서명
- **현재 구독 정보**:
  - 요금제명, 월 이용료
  - 다음 결제일, 결제 수단
  - 사용량 (현장 수, 사용자 수)
  - 사용률 (제한 대비 현재 사용량)
- **요금제 변경**:
  - 업그레이드/다운그레이드
  - 즉시 적용 vs 다음 결제일 적용
  - 차액 정산 처리
  - 변경 사유 및 승인 프로세스
- **결제 수단 관리**:
  - 신용카드 등록/변경/삭제
  - CMS 자동이체 설정
  - 결제 내역 조회 (최근 12개월)
  - 세금계산서 발행 요청

**[HQ-01-03] 구독 현황 모니터링**
- **경로**: `/hq/subscription/monitoring`
- **사용량 대시보드**:
  - 실시간 사용량 (현장 수, 활성 사용자 수)
  - 월간 사용량 추이 차트
  - 제한 임계치 알림 (80%, 90%, 100%)
  - 예상 초과 비용 계산
- **결제 현황**:
  - 결제 성공/실패 이력
  - 미납금 현황 및 연체료
  - 자동 결제 설정 상태
  - 다음 결제 예정일 및 예상 금액
- **서비스 상태**:
  - 구독 상태 (정상, 일시중지, 해지예정)
  - 서비스 제한 사항
  - 업그레이드 권장 알림
  - 고객 지원 연락처

**[HQ-01-04] 요금제 및 청구서 관리**
- **경로**: `/hq/subscription/billing`
- **요금제 정보**:
  - 현재 요금제 상세 정보
  - 포함 서비스 및 제한사항
  - 추가 서비스 옵션
  - 요금제 비교표
- **청구서 관리**:
  - 월별 청구서 조회 및 다운로드
  - 세금계산서 발행 내역
  - 결제 영수증 출력
  - 청구 이의제기 및 문의

#### 6.1.3 사용자 스토리
```
AS A 본사 관리자
I WANT TO 회사 정보와 구독을 체계적으로 관리할 수 있기를
SO THAT 우리 회사에 맞는 서비스 환경을 구성하고 비용을 효율적으로 관리할 수 있다

수용 기준:
- 회사 정보 변경 시 즉시 반영
- 로고 업로드 시 자동 리사이징
- 구독 변경 시 명확한 안내 메시지
- 결제 실패 시 알림 및 재시도 옵션
- 사용량 임계치 도달 시 자동 알림
- 청구서 및 세금계산서 자동 발행
```

```
AS A 신규 고객사 담당자
I WANT TO 온라인으로 간편하게 구독을 신청할 수 있기를
SO THAT 빠르게 서비스를 시작하고 우리 회사 규모에 맞는 요금제를 선택할 수 있다

수용 기준:
- 요금제별 기능 비교표 제공
- 예상 비용 자동 계산
- 결제 수단 간편 등록
- 신청 완료 후 즉시 서비스 이용 가능
```

```
AS A 기존 고객사 담당자
I WANT TO 구독 현황을 실시간으로 모니터링할 수 있기를
SO THAT 사용량을 관리하고 비용을 예측하여 예산을 효율적으로 운영할 수 있다

수용 기준:
- 실시간 사용량 대시보드 제공
- 제한 임계치 도달 시 사전 알림
- 월별 사용량 추이 분석
- 결제 내역 및 청구서 쉽게 조회
```

### 6.2 현장 관리 (HQ-02)
#### 6.2.1 기능 개요
회사 소속 모든 현장의 개설, 설정, 모니터링을 수행합니다.

#### 6.2.2 상세 기능
**[HQ-02-01] 현장 목록 및 현황**
- **경로**: `/hq/sites`
- **목록 정보**:
  - 현장명, 위치, 공사 기간
  - 현장 관리자, 팀 수, 노무자 수
  - 진행 상태, 마지막 활동일
- **필터링**: 상태별, 지역별, 관리자별
- **정렬**: 생성일, 활동일, 규모순

**[HQ-02-02] 신규 현장 개설**
- **경로**: `/hq/sites/new`
- **필수 정보**:
  - 현장명, 공사명
  - 주소 (도로명 주소 API 연동)
  - 공사 기간 (시작일, 종료일)
  - 현장 관리자 지정
- **선택 정보**:
  - 현장 설명, 특이사항
  - 안면인식기 시리얼 번호
  - 표준 공종/직종 적용 여부

**[HQ-02-03] 현장 상세 관리**
- **경로**: `/hq/sites/{siteId}`
- **기본 정보 수정**
- **현장 관리자 변경**
- **현장 상태 관리**: 활성, 일시중지, 완료
- **통계 조회**: 출역 현황, 계약 체결률, 일보 제출률

#### 6.2.3 사용자 스토리
```
AS A 본사 관리자
I WANT TO 모든 현장을 중앙에서 관리할 수 있기를
SO THAT 현장별 진행 상황을 파악하고 효율적으로 운영할 수 있다

수용 기준:
- 현장 개설 시 관리자에게 자동 알림
- 현장 목록에서 핵심 지표 한눈에 확인
- 현장별 상세 통계 제공
- 현장 상태 변경 시 관련자 알림
```

### 6.3 표준 관리 (HQ-03)
#### 6.3.1 기능 개요
전사 표준 공종, 직종, 노무 단가를 설정하고 관리합니다.

#### 6.3.2 상세 기능
**[HQ-03-01] 공종 관리**
- **경로**: `/hq/standards/work-types`
- **표준 공종**: 토공, 콘크리트공, 철근공, 조적공 등
- **공종별 설정**:
  - 공종명, 코드
  - 기본 작업 시간 (8시간, 10시간 등)
  - 위험도 등급 (안전 관리 기준)
- **현장별 적용**: 표준 공종을 현장에 일괄 적용

**[HQ-03-02] 직종 및 단가 관리**
- **경로**: `/hq/standards/job-types`
- **직종 분류**: 기능공, 보통인부, 특별인부
- **단가 설정**:
  - 기본 일당 (8시간 기준)
  - 연장 근무 시급
  - 야간/휴일 할증률
- **지역별 차등**: 수도권, 지방 등 지역별 단가 차등 적용

**[HQ-03-03] 계약서 템플릿 관리**
- **경로**: `/hq/standards/contract-templates`
- **표준 근로계약서**: 회사 표준 계약서 템플릿
- **변수 바인딩**: 현장명, 공종, 단가 등 자동 입력
- **전자서명 영역**: 서명 위치 및 크기 설정

#### 6.3.3 사용자 스토리
```
AS A 본사 관리자
I WANT TO 전사 표준을 설정하고 관리할 수 있기를
SO THAT 모든 현장에서 일관된 기준으로 운영할 수 있다

수용 기준:
- 표준 설정 변경 시 현장에 자동 반영
- 단가 변경 이력 추적 가능
- 계약서 템플릿 미리보기 제공
- 현장별 표준 적용 현황 확인
```

### 6.4 전사 대시보드 (HQ-04)
#### 6.4.1 기능 개요
전체 현장의 핵심 지표를 실시간으로 모니터링합니다.

#### 6.4.2 상세 기능
**[HQ-04-01] 핵심 지표 (KPI)**
- **경로**: `/hq/dashboard`
- **실시간 지표**:
  - 전체 현장 수 (활성/완료)
  - 금일 출역 인원 (전체/현장별)
  - 미서명 계약서 수
  - 미제출 일보 수
- **월간 통계**:
  - 총 공수 (man-day)
  - 평균 출역률
  - 계약 체결률
  - 일보 제출률

**[HQ-04-02] 현장별 현황**
- **현장 카드 형태로 표시**:
  - 현장명, 관리자
  - 금일 출역 인원/전체 인원
  - 진행률 (공정률)
  - 최근 활동 (일보 제출, 계약 체결 등)
- **상태별 색상 구분**:
  - 정상: 초록색
  - 주의: 노란색 (출역률 저조, 일보 미제출)
  - 위험: 빨간색 (장기간 미활동)

**[HQ-04-03] 알림 센터**
- **실시간 알림**:
  - 새로운 현장 가입 요청
  - 결제 실패 알림
  - 시스템 점검 공지
- **업무 알림**:
  - 승인 대기 건 (현장 개설, 사용자 가입)
  - 기한 임박 (계약 만료, 결제일)

#### 6.4.3 사용자 스토리
```
AS A 본사 관리자
I WANT TO 전체 현장의 상황을 한눈에 파악할 수 있기를
SO THAT 신속한 의사결정과 문제 해결을 할 수 있다

수용 기준:
- 대시보드 로딩 시간 3초 이내
- 실시간 데이터 자동 갱신 (30초 간격)
- 문제 상황 시 즉시 알림
- 모바일에서도 핵심 지표 확인 가능
```
---

## 7. 현장 관리자 (ROLE_SITE) 기능 명세

### 7.1 현장 운영 관리 (SITE-01)
#### 7.1.1 기능 개요
담당 현장의 일상적인 운영 업무를 관리합니다.

#### 7.1.2 상세 기능
**[SITE-01-01] 현장 대시보드**
- **경로**: `/site/dashboard`
- **금일 현황**:
  - 출역 인원 (출근/퇴근/현재 현장)
  - 작업 팀 현황 (배정/진행/완료)
  - 미처리 업무 (승인 대기, 일보 미제출)
- **주간 통계**:
  - 일별 출역 인원 차트
  - 공종별 투입 인원
  - 계약 체결 현황

**[SITE-01-02] 현장 설정**
- **경로**: `/site/settings`
- **기본 정보**: 현장명, 주소, 공사 기간
- **운영 설정**:
  - 출근/퇴근 시간 (기본 08:00/18:00)
  - 점심시간 (12:00-13:00)
  - 연장근무 허용 여부
- **안면인식 설정**:
  - 인식기 시리얼 번호
  - 인식 임계값 (정확도)
  - 동기화 시간 (매일 00:00)

#### 7.1.3 사용자 스토리
```
AS A 현장 관리자
I WANT TO 현장 운영 상황을 실시간으로 파악할 수 있기를
SO THAT 효율적인 현장 관리와 신속한 의사결정을 할 수 있다

수용 기준:
- 대시보드에서 핵심 정보 즉시 확인
- 문제 상황 발생 시 알림 수신
- 모바일에서도 주요 기능 사용 가능
- 설정 변경 시 즉시 반영
```

### 7.2 팀 및 인력 관리 (SITE-02)
#### 7.2.1 기능 개요
현장 내 작업 팀과 노무자를 관리합니다.

#### 7.2.2 상세 기능
**[SITE-02-01] 팀 관리**
- **경로**: `/site/teams`
- **팀 목록**:
  - 팀명, 팀장, 팀원 수
  - 주요 공종, 현재 작업 상태
  - 최근 출역률, 계약 체결률
- **팀 등록**:
  - 팀장 초대 (SMS 링크 발송)
  - 팀 정보 입력 (팀명, 주요 공종)
  - 승인/반려 처리

**[SITE-02-02] 노무자 관리**
- **경로**: `/site/workers`
- **노무자 목록**:
  - 이름, 연락처, 소속 팀
  - 계약 상태, 안면인식 등록 여부
  - 최근 출역일, 누적 공수
- **필터링**: 팀별, 공종별, 계약 상태별
- **일괄 작업**:
  - 계약서 발송
  - 안면인식 등록 요청
  - 팀 이동

**[SITE-02-03] 초대 및 승인**
- **경로**: `/site/invitations`
- **초대 관리**:
  - 팀장 초대 링크 생성
  - 초대 상태 추적 (발송/확인/가입완료)
  - 초대 취소 및 재발송
- **가입 승인**:
  - 신규 가입자 승인/반려
  - 승인 시 역할 및 권한 부여
  - 반려 시 사유 입력

#### 7.2.3 사용자 스토리
```
AS A 현장 관리자
I WANT TO 현장 내 모든 팀과 노무자를 체계적으로 관리할 수 있기를
SO THAT 적절한 인력 배치와 효율적인 작업 진행을 할 수 있다

수용 기준:
- 팀/노무자 정보를 한눈에 파악
- 초대 및 승인 프로세스 간소화
- 계약 미체결자 쉽게 식별
- 팀별 성과 비교 분석 가능
```

### 7.3 작업 지시 및 배정 (SITE-03)
#### 7.3.1 기능 개요
팀별 작업을 계획하고 배정합니다.

#### 7.3.2 상세 기능
**[SITE-03-01] 작업 계획**
- **경로**: `/site/work-assignments`
- **작업 요청 생성**:
  - 작업일 (내일 기준)
  - 공종, 작업 위치
  - 필요 인원 수
  - 특이사항, 주의사항
- **팀 선택**: 해당 공종 가능 팀 목록에서 선택
- **요청 발송**: 선택된 팀장에게 Push 알림 발송

**[SITE-03-02] 작업 현황 관리**
- **요청 상태 추적**:
  - 발송됨 (팀장 미확인)
  - 확인됨 (팀장 확인, 답변 대기)
  - 수락됨 (투입 인원 확정)
  - 거부됨 (거부 사유 포함)
- **투입 인원 확인**: 팀장이 제출한 투입 예정 인원
- **최종 승인**: 투입 인원 검토 후 최종 승인

**[SITE-03-03] 작업 일정 관리**
- **경로**: `/site/work-schedule`
- **캘린더 뷰**: 월간/주간 작업 일정 표시
- **팀별 색상**: 팀별로 다른 색상으로 구분
- **드래그 앤 드롭**: 작업 일정 변경 (간단한 조정)

#### 7.3.3 사용자 스토리
```
AS A 현장 관리자
I WANT TO 팀별 작업을 효율적으로 배정하고 관리할 수 있기를
SO THAT 현장 작업이 계획대로 진행되고 인력 낭비를 방지할 수 있다

수용 기준:
- 작업 요청 생성이 간단하고 직관적
- 팀장의 응답을 실시간으로 확인
- 작업 일정을 시각적으로 관리
- 과거 작업 이력 조회 가능
```

### 7.4 출역 관리 및 마감 (SITE-04)
#### 7.4.1 기능 개요
일일 출역 현황을 확인하고 공수를 확정합니다.

#### 7.4.2 상세 기능
**[SITE-04-01] 실시간 출역 현황**
- **경로**: `/site/attendance/today`
- **현재 현장 인원**:
  - 출근 완료 (안면인식 확인)
  - 현장 내 (GPS 기준)
  - 퇴근 완료
- **팀별 현황**: 팀별 출역 인원 및 비율
- **이상 상황**: 미출근, 조기퇴근, 인식 실패

**[SITE-04-02] 출역 로그 관리**
- **경로**: `/site/attendance/logs`
- **안면인식 로그**:
  - 인식 시간, 인식 정확도
  - 사진 (썸네일)
  - GPS 좌표 (현장 내/외 구분)
- **수동 보정**:
  - 인식 실패 시 수동 출근 처리
  - 조기퇴근 사유 입력
  - 지각/결근 처리

**[SITE-04-03] 일일 출역 마감**
- **경로**: `/site/attendance/finalize`
- **마감 프로세스**:
  1. 안면인식 로그 + 팀장 보고 대조
  2. 이상 건 확인 및 보정
  3. 최종 공수 확정
  4. 마감 처리 (수정 불가)
- **마감 결과**: 개인별 공수, 팀별 합계, 전체 현황

#### 7.4.3 사용자 스토리
```
AS A 현장 관리자
I WANT TO 정확한 출역 관리와 공정한 공수 산정을 할 수 있기를
SO THAT 노무자들의 신뢰를 얻고 정확한 급여 지급 기준을 만들 수 있다

수용 기준:
- 실시간 출역 현황 모니터링
- 안면인식과 수동 보정의 조화
- 투명한 마감 프로세스
- 마감 후 데이터 무결성 보장
```

### 7.5 공사일보 관리 (SITE-05)
#### 7.5.1 기능 개요
일일 작업 내용을 취합하여 공사일보를 작성합니다.

#### 7.5.2 상세 기능
**[SITE-05-01] 일보 취합**
- **경로**: `/site/daily-reports`
- **자동 수집 정보**:
  - 날씨, 기온 (기상청 API)
  - 출역 인원 (안면인식 데이터)
  - 투입 장비 (사전 등록 기준)
- **팀별 제출 내용**:
  - 작업 내용, 진행률
  - 작업 사진
  - 특이사항, 안전사고

**[SITE-05-02] 일보 편집 및 승인**
- **편집 기능**:
  - 자동 수집 정보 수정
  - 팀별 내용 통합 편집
  - 추가 정보 입력 (자재 반입, 검사 등)
- **승인 프로세스**:
  - 임시 저장 (수정 가능)
  - 최종 승인 (PDF 생성)
  - 본사 전송

**[SITE-05-03] 일보 이력 관리**
- **경로**: `/site/daily-reports/history`
- **월간 일보**: 월별 일보 목록 및 통계
- **PDF 다운로드**: 승인된 일보 PDF 다운로드
- **수정 이력**: 일보 수정 내역 추적

#### 7.5.3 사용자 스토리
```
AS A 현장 관리자
I WANT TO 정확하고 완성도 높은 공사일보를 효율적으로 작성할 수 있기를
SO THAT 본사 보고와 공사 기록 관리를 체계적으로 할 수 있다

수용 기준:
- 자동 수집 정보로 작성 시간 단축
- 팀별 제출 내용 쉽게 통합
- 일보 품질 검증 기능
- PDF 출력 시 표준 양식 적용
```
---

## 8. 팀장 (ROLE_TEAM) 기능 명세

### 8.1 작업 요청 관리 (TEAM-01)
#### 8.1.1 기능 개요
현장 관리자로부터 받은 작업 요청을 검토하고 수락/거부를 결정합니다.

#### 8.1.2 상세 기능
**[TEAM-01-01] 작업 요청 알림**
- **Push 알림**: 새로운 작업 요청 시 즉시 알림
- **알림 내용**: 작업일, 공종, 위치, 필요 인원
- **긴급도 표시**: 일반/긴급 구분
- **응답 기한**: 요청 후 2시간 이내 응답 권장

**[TEAM-01-02] 작업 요청 상세 조회**
- **경로**: `/team/work-requests/{requestId}`
- **요청 정보**:
  - 작업일시, 공종, 작업 위치
  - 필요 인원 수, 예상 작업 시간
  - 특이사항, 안전 주의사항
  - 단가 정보 (기본 일당, 연장 수당)
- **현장 정보**: 현장 위치, 접근 방법, 주차 안내

**[TEAM-01-03] 작업 수락/거부**
- **수락 프로세스**:
  1. 투입 가능 인원 확인
  2. 투입 예정 팀원 선택
  3. 예상 공수 입력
  4. 수락 확정
- **거부 프로세스**:
  1. 거부 사유 선택 (인원 부족, 일정 충돌, 기타)
  2. 상세 사유 입력 (선택)
  3. 거부 확정
- **부분 수락**: 요청 인원보다 적은 인원으로 수락 가능

#### 8.1.3 사용자 스토리
```
AS A 팀장
I WANT TO 작업 요청을 신속하고 정확하게 검토할 수 있기를
SO THAT 팀원들의 일정을 효율적으로 관리하고 수익을 극대화할 수 있다

수용 기준:
- 작업 요청 알림을 즉시 수신
- 요청 내용을 명확하게 파악
- 팀원 일정과 대조하여 수락/거부 결정
- 응답 후 현장 관리자에게 자동 알림
```

### 8.2 팀원 관리 (TEAM-02)
#### 8.2.1 기능 개요
팀 소속 노무자들을 관리하고 작업에 배정합니다.

#### 8.2.2 상세 기능
**[TEAM-02-01] 팀원 목록 관리**
- **경로**: `/team/members`
- **팀원 정보**:
  - 이름, 연락처, 주요 공종
  - 계약 상태, 안면인식 등록 여부
  - 최근 출역일, 월간 공수
  - 기술 등급 (초급/중급/고급)
- **상태 관리**: 활성/휴직/퇴사 상태 변경
- **정렬/필터**: 이름순, 공수순, 공종별, 상태별

**[TEAM-02-02] 팀원 초대**
- **경로**: `/team/invite`
- **초대 방식**:
  - SMS 초대 링크 발송
  - QR 코드 생성 (현장에서 스캔)
  - 직접 등록 (팀장이 대신 등록)
- **초대 정보**: 이름, 연락처, 주요 공종
- **승인 프로세스**: 현장 관리자 최종 승인 필요

**[TEAM-02-03] 작업 배정**
- **경로**: `/team/assignments`
- **배정 기준**:
  - 공종 적합성
  - 기술 수준
  - 최근 출역 이력
  - 개인 선호도
- **배정 결과**: 배정된 팀원에게 자동 알림

#### 8.2.3 사용자 스토리
```
AS A 팀장
I WANT TO 팀원들을 체계적으로 관리하고 적절히 배정할 수 있기를
SO THAT 작업 품질을 높이고 팀원들의 만족도를 향상시킬 수 있다

수용 기준:
- 팀원 정보를 한눈에 파악
- 초대 프로세스 간소화
- 공종별 적합한 인원 배정
- 팀원별 성과 추적 가능
```

### 8.3 간편 일보 작성 (TEAM-03)
#### 8.3.1 기능 개요
일일 작업 내용을 간단하게 기록하여 현장 관리자에게 보고합니다.

#### 8.3.2 상세 기능
**[TEAM-03-01] 작업 사진 촬영**
- **카메라 연동**: Capacitor Camera API 사용
- **사진 요구사항**:
  - 작업 전/후 비교 사진
  - 안전 장비 착용 확인
  - 작업 진행 상황
- **자동 정보**: GPS 좌표, 촬영 시간 자동 기록
- **사진 압축**: 업로드 최적화를 위한 자동 압축

**[TEAM-03-02] 작업 내용 입력**
- **경로**: `/team/daily-report`
- **기본 정보**:
  - 작업 공종, 작업 위치
  - 투입 인원 (자동 입력, 수정 가능)
  - 작업 시간 (시작/종료)
- **작업 내용**:
  - 주요 작업 내용 (텍스트)
  - 진행률 (%) 
  - 완료/미완료 구분
- **특이사항**:
  - 안전사고, 장비 고장
  - 날씨로 인한 작업 지연
  - 기타 특이사항

**[TEAM-03-03] 일보 제출**
- **임시 저장**: 작성 중 자동 저장
- **제출 전 검토**: 필수 항목 확인
- **제출 완료**: 현장 관리자에게 자동 알림
- **수정 가능**: 현장 관리자 승인 전까지 수정 가능

#### 8.3.3 사용자 스토리
```
AS A 팀장
I WANT TO 간단하고 빠르게 일보를 작성할 수 있기를
SO THAT 현장 관리자에게 정확한 작업 현황을 보고할 수 있다

수용 기준:
- 모바일에서 쉽게 사진 촬영 및 업로드
- 필수 정보 자동 입력으로 입력 시간 단축
- 오프라인에서도 작성 가능 (동기화)
- 제출 후 확인 메시지 표시
```

### 8.4 출역 현황 조회 (TEAM-04)
#### 8.4.1 기능 개요
팀원들의 출역 현황을 실시간으로 확인하고 관리합니다.

#### 8.4.2 상세 기능
**[TEAM-04-01] 실시간 출역 현황**
- **경로**: `/team/attendance/today`
- **팀원별 상태**:
  - 출근 완료 (안면인식 확인)
  - 현장 내 (GPS 기준)
  - 퇴근 완료
  - 미출근/지각
- **알림 기능**: 지각자, 미출근자 알림
- **연락 기능**: 미출근자에게 직접 연락

**[TEAM-04-02] 출역 이력 조회**
- **경로**: `/team/attendance/history`
- **조회 기간**: 일별, 주별, 월별
- **팀원별 통계**:
  - 출역 일수, 총 공수
  - 출근율, 지각 횟수
  - 예상 급여 (단가 기준)
- **이상 건 관리**: 출역 이상 건 확인 및 이의 제기

#### 8.4.3 사용자 스토리
```
AS A 팀장
I WANT TO 팀원들의 출역 현황을 실시간으로 파악할 수 있기를
SO THAT 작업 계획을 조정하고 팀원들을 적절히 관리할 수 있다

수용 기준:
- 실시간 출역 상태 확인
- 문제 상황 시 즉시 알림
- 과거 출역 이력 쉽게 조회
- 급여 예상액 확인 가능
```

---

## 9. 노무자 (ROLE_WORKER) 기능 명세

### 9.1 출역 관리 (WORK-01)
#### 9.1.1 기능 개요
개인의 출역 현황을 조회하고 관리합니다.

#### 9.1.2 상세 기능
**[WORK-01-01] 금일 출역 현황**
- **경로**: `/worker/attendance/today`
- **출근 상태**: 미출근/출근완료/퇴근완료
- **출근 시간**: 안면인식 기록 시간
- **현재 위치**: GPS 기반 현장 내/외 표시
- **예상 퇴근**: 8시간 기준 예상 퇴근 시간
- **연장 근무**: 연장 근무 시 자동 계산

**[WORK-01-02] 보조 출퇴근 체크**
- **GPS 체크인**: 안면인식 보조 수단
- **WiFi 체크인**: 현장 WiFi 연결 시 자동 체크
- **수동 체크**: 기술적 문제 시 수동 출퇴근 기록
- **위치 확인**: 현장 경계 내 위치 확인

**[WORK-01-03] 출역 이력 조회**
- **경로**: `/worker/attendance/history`
- **캘린더 뷰**: 월간 출역 캘린더
- **일별 상세**: 출근/퇴근 시간, 총 근무 시간
- **월간 통계**: 총 출역일, 총 공수, 예상 급여
- **이상 건 확인**: 지각, 조기퇴근, 결근 내역

#### 9.1.3 사용자 스토리
```
AS A 노무자
I WANT TO 내 출역 현황을 정확하게 확인할 수 있기를
SO THAT 급여 계산이 정확한지 확인하고 근무 계획을 세울 수 있다

수용 기준:
- 실시간 출근 상태 확인
- 과거 출역 이력 쉽게 조회
- 예상 급여 자동 계산
- 이상 건 발생 시 알림
```

### 9.2 전자계약 관리 (WORK-02)
#### 9.2.1 기능 개요
근로계약서 및 각종 서약서에 전자서명을 수행합니다.

#### 9.2.2 상세 기능
**[WORK-02-01] 계약서 목록**
- **경로**: `/worker/contracts`
- **계약 상태**:
  - 서명 대기 (빨간 배지)
  - 서명 완료 (초록 배지)
  - 만료 예정 (노란 배지)
- **계약 종류**: 근로계약서, 안전교육서약서, 개인정보동의서
- **긴급도**: 서명 기한 임박 시 우선 표시

**[WORK-02-02] 계약서 확인 및 서명**
- **경로**: `/worker/contracts/{contractId}/sign`
- **계약서 내용**:
  - PDF 뷰어로 계약서 내용 표시
  - 확대/축소, 페이지 이동 기능
  - 중요 조항 하이라이트
- **전자서명**:
  - Canvas 기반 서명 패드
  - 서명 지우기/다시 그리기
  - 서명 미리보기
- **위치 정보**: GPS 좌표 자동 기록 (서명 장소 확인)

**[WORK-02-03] 서명 완료 처리**
- **서명 검증**: 서명 데이터 유효성 확인
- **PDF 생성**: 서명이 포함된 최종 PDF 생성
- **Hash 생성**: 위변조 방지를 위한 Hash 값 생성
- **완료 알림**: 서명 완료 확인 메시지
- **사본 제공**: 서명 완료된 계약서 사본 다운로드

#### 9.2.3 사용자 스토리
```
AS A 노무자
I WANT TO 계약서에 간편하게 전자서명할 수 있기를
SO THAT 빠르게 작업을 시작하고 법적 보호를 받을 수 있다

수용 기준:
- 계약서 내용을 명확하게 확인
- 직관적인 서명 인터페이스
- 서명 완료 후 즉시 확인
- 서명된 계약서 사본 보관
```

### 9.3 개인정보 관리 (WORK-03)
#### 9.3.1 기능 개요
개인 프로필과 안면인식 정보를 관리합니다.

#### 9.3.2 상세 기능
**[WORK-03-01] 기본 정보 관리**
- **경로**: `/worker/profile`
- **개인 정보**:
  - 이름, 연락처 (수정 가능)
  - 주민번호 (마스킹 표시, 수정 불가)
  - 주소 (도로명 주소 API 연동)
- **계좌 정보**:
  - 은행명, 계좌번호
  - 예금주명 (자동 검증)
  - 급여 수령 계좌 설정
- **기술 정보**:
  - 주요 공종, 기술 등급
  - 자격증 정보
  - 경력 사항

**[WORK-03-02] 안면인식 사진 관리**
- **경로**: `/worker/face-registration`
- **사진 촬영**:
  - 전면 카메라 사용
  - 얼굴 가이드라인 표시
  - 조명 및 각도 안내
- **사진 품질 검증**:
  - 얼굴 인식 가능 여부 확인
  - 화질 및 선명도 검사
  - 재촬영 안내
- **등록 완료**: FaceNet 서버 전송 및 임베딩 생성

**[WORK-03-03] 개인정보 보안**
- **비밀번호 변경**: 소셜 로그인 연동 계정 비밀번호
- **로그인 이력**: 최근 로그인 기록 확인
- **개인정보 동의**: 개인정보 처리방침 동의 관리
- **계정 삭제**: 서비스 탈퇴 및 개인정보 삭제 요청

#### 9.3.3 사용자 스토리
```
AS A 노무자
I WANT TO 내 개인정보를 안전하게 관리할 수 있기를
SO THAT 정확한 급여 지급과 개인정보 보호를 받을 수 있다

수용 기준:
- 개인정보 수정이 간단하고 안전
- 안면인식 사진 등록이 쉬움
- 계좌 정보 자동 검증
- 개인정보 보안 기능 제공
```
---

## 10. 핵심 비즈니스 프로세스

### 10.1 안면인식 데이터 파이프라인
#### 10.1.1 프로세스 개요
노무자의 안면 데이터를 수집하여 현장 안면인식기에 동기화하는 전체 프로세스입니다.

#### 10.1.2 상세 프로세스
**[FACE-01] 안면 데이터 등록**
1. **노무자 사진 촬영**
   - 모바일 앱에서 전면 카메라 사용
   - 얼굴 가이드라인 및 품질 검증
   - 여러 각도 사진 촬영 (정면, 좌측, 우측)

2. **데이터 전처리**
   - 이미지 품질 검증 (해상도, 선명도)
   - 얼굴 영역 추출 및 정규화
   - S3 저장 및 메타데이터 DB 기록

3. **FaceNet 임베딩 생성**
   - FaceNet 서버로 이미지 전송
   - 512차원 벡터 임베딩 생성
   - 임베딩 데이터 DB 저장

**[FACE-02] 일일 동기화 배치**
- **실행 시간**: 매일 00:00 (자정)
- **처리 로직**:
  ```
  1. 금일 작업 배정 승인된 노무자 조회
  2. 해당 노무자의 Face Embedding 데이터 추출
  3. 현장별 안면인식기 활성 리스트 생성
  4. Edge Device 또는 Cloud API로 데이터 전송
  5. 동기화 완료 상태 업데이트
  ```

**[FACE-03] 실시간 인식 처리**
1. **출입 감지**: 현장 안면인식기에서 얼굴 감지
2. **임베딩 추출**: 실시간 얼굴 임베딩 생성
3. **매칭 수행**: 활성 리스트와 유사도 비교
4. **결과 전송**: 인식 결과를 SmartCON 서버로 전송
5. **출역 기록**: 출근/퇴근 로그 자동 생성

#### 10.1.3 기술 요구사항
- **임베딩 정확도**: 99.5% 이상
- **인식 속도**: 1초 이내
- **동기화 시간**: 현장당 5분 이내
- **데이터 보안**: 개인정보 암호화 저장

### 10.2 작업 배정 및 승인 프로세스
#### 10.2.1 프로세스 개요
현장 관리자의 작업 요청부터 팀장 수락, 최종 승인까지의 전체 워크플로우입니다.

#### 10.2.2 상세 프로세스
**[WORK-ASSIGN-01] 작업 요청 생성**
1. **현장 관리자 요청**
   - 작업일, 공종, 위치, 필요 인원 입력
   - 적합한 팀 목록 자동 추천
   - 팀장에게 Push 알림 발송

2. **팀장 응답 대기**
   - 요청 상태: "발송됨" → "확인됨"
   - 응답 기한: 2시간 (설정 가능)
   - 미응답 시 다른 팀에게 자동 재요청

**[WORK-ASSIGN-02] 팀장 검토 및 응답**
1. **요청 검토**
   - 작업 내용 및 조건 확인
   - 팀원 일정 및 가용 인원 확인
   - 수익성 분석 (단가 × 예상 공수)

2. **수락 처리**
   - 투입 예정 팀원 선택
   - 예상 공수 및 완료 시간 입력
   - 특이사항 또는 요청사항 기재

3. **거부 처리**
   - 거부 사유 선택 (인원부족, 일정충돌, 단가부적절 등)
   - 상세 사유 입력 (선택사항)
   - 대안 제시 (다른 날짜, 인원 조정 등)

**[WORK-ASSIGN-03] 최종 승인 및 확정**
1. **현장 관리자 검토**
   - 팀장 응답 내용 확인
   - 투입 인원 및 공수 검토
   - 필요시 조건 재협상

2. **최종 승인**
   - 작업 배정 확정
   - 관련자 전체 알림 발송
   - 안면인식 동기화 대상 추가

#### 10.2.3 상태 관리
| 상태 | 설명 | 다음 가능 상태 |
|------|------|----------------|
| REQUESTED | 요청 발송됨 | VIEWED, EXPIRED |
| VIEWED | 팀장 확인함 | ACCEPTED, REJECTED |
| ACCEPTED | 팀장 수락함 | APPROVED, MODIFIED |
| REJECTED | 팀장 거부함 | REQUESTED (재요청) |
| APPROVED | 최종 승인됨 | COMPLETED |
| COMPLETED | 작업 완료됨 | - |

### 10.3 전자계약 프로세스
#### 10.3.1 프로세스 개요
근로계약서 자동 생성부터 전자서명, PDF 생성까지의 전체 프로세스입니다.

#### 10.3.2 상세 프로세스
**[CONTRACT-01] 계약서 자동 생성**
1. **트리거 조건**
   - 신규 노무자 현장 배정 시
   - 기존 계약 만료 30일 전
   - 근무 조건 변경 시

2. **템플릿 바인딩**
   ```
   - 회사 정보: 상호, 사업자번호, 대표자명
   - 현장 정보: 현장명, 주소, 공사기간
   - 노무자 정보: 성명, 주민번호, 연락처
   - 근무 조건: 공종, 일당, 근무시간
   - 계약 기간: 시작일, 종료일
   ```

3. **계약서 초안 생성**
   - 표준 템플릿에 데이터 매핑
   - PDF 형태로 임시 생성
   - 서명 영역 좌표 설정

**[CONTRACT-02] 전자서명 수행**
1. **노무자 알림**
   - Push 알림 및 SMS 발송
   - 서명 기한 안내 (일반적으로 3일)
   - 딥링크를 통한 직접 접근

2. **계약서 확인**
   - PDF 뷰어로 계약 내용 표시
   - 중요 조항 하이라이트
   - 궁금한 사항 문의 기능

3. **서명 수행**
   - Canvas 기반 서명 패드
   - 서명 품질 검증
   - GPS 좌표 자동 기록

**[CONTRACT-03] 최종 처리**
1. **PDF 생성**
   - 서명이 포함된 최종 PDF 생성
   - 전자서명 인증서 첨부
   - S3 저장 및 접근 권한 설정

2. **Hash 생성 및 검증**
   - SHA-256 Hash 값 생성
   - 블록체인 기반 무결성 보장 (선택)
   - 위변조 방지 메커니즘

3. **완료 처리**
   - 계약 상태 "서명완료"로 변경
   - 관련자 전체 알림 발송
   - 계약서 사본 자동 배포

#### 10.3.3 보안 요구사항
- **서명 데이터 암호화**: AES-256 암호화
- **접근 권한 제어**: 당사자만 열람 가능
- **감사 로그**: 모든 접근 및 변경 이력 기록
- **법적 효력**: 전자서명법 준수

### 10.4 정산 및 급여 계산 프로세스
#### 10.4.1 프로세스 개요
출역 데이터를 기반으로 노무비를 계산하고 지급하는 프로세스입니다.

#### 10.4.2 상세 프로세스
**[PAYROLL-01] 출역 데이터 집계**
1. **기준 기간 설정**
   - 월간 정산: 매월 1일~말일
   - 주간 정산: 월요일~일요일
   - 일간 정산: 당일 (일용직)

2. **출역 데이터 수집**
   ```sql
   SELECT 
     worker_id,
     work_date,
     check_in_time,
     check_out_time,
     total_hours,
     overtime_hours,
     work_type,
     hourly_rate
   FROM attendance_logs 
   WHERE work_date BETWEEN ? AND ?
     AND status = 'FINALIZED'
   ```

3. **공수 계산**
   - 기본 공수: 8시간 = 1공수
   - 연장 공수: 초과 시간 × 1.5배율
   - 야간 공수: 22:00~06:00 × 1.3배율
   - 휴일 공수: 휴일 근무 × 2.0배율

**[PAYROLL-02] 급여 계산**
1. **기본 급여 계산**
   ```
   기본급 = 기본공수 × 일당
   연장수당 = 연장공수 × 일당 × 1.5
   야간수당 = 야간공수 × 일당 × 0.3
   휴일수당 = 휴일공수 × 일당 × 1.0
   ```

2. **공제 항목 계산**
   - 소득세: 급여 구간별 세율 적용
   - 지방소득세: 소득세 × 10%
   - 국민연금: 급여 × 4.5% (상한선 적용)
   - 건강보험: 급여 × 3.545%
   - 고용보험: 급여 × 0.9%

3. **실수령액 계산**
   ```
   실수령액 = 총급여 - 총공제액
   ```

**[PAYROLL-03] 급여명세서 생성**
1. **명세서 데이터 구성**
   - 개인정보: 성명, 주민번호(마스킹)
   - 근무정보: 근무일수, 총공수, 평균일당
   - 급여내역: 기본급, 각종 수당
   - 공제내역: 세금, 4대보험
   - 실수령액: 최종 지급액

2. **PDF 생성**
   - 표준 급여명세서 템플릿 사용
   - 회사 로고 및 직인 자동 삽입
   - 전자서명 및 Hash 값 포함

3. **배포 및 알림**
   - 개인별 급여명세서 앱 내 제공
   - SMS 알림 발송
   - 이메일 첨부 발송 (선택)

#### 10.4.3 정산 주기별 특징
| 정산 주기 | 장점 | 단점 | 적용 대상 |
|-----------|------|------|-----------|
| 일간 | 현금 흐름 빠름 | 관리 부담 큼 | 일용직 |
| 주간 | 관리 효율성 | 초기 자금 부담 | 단기 프로젝트 |
| 월간 | 표준적 방식 | 현금 흐름 지연 | 정규직 |

---

## 11. 외부 시스템 연동 명세

### 11.1 FaceNet 안면인식 시스템
#### 11.1.1 연동 개요
FaceNet 기반 안면인식 서버와의 API 연동을 통해 얼굴 임베딩 생성 및 매칭을 수행합니다.

#### 11.1.2 API 명세
**[FACE-API-01] 얼굴 임베딩 생성**
```http
POST /api/v1/face/embedding
Content-Type: multipart/form-data

Parameters:
- image: 얼굴 이미지 파일 (JPG, PNG)
- quality: 품질 검증 여부 (true/false)

Response:
{
  "success": true,
  "embedding": [0.123, -0.456, ...], // 512차원 벡터
  "confidence": 0.95,
  "face_detected": true,
  "quality_score": 0.87
}
```

**[FACE-API-02] 얼굴 매칭**
```http
POST /api/v1/face/match
Content-Type: application/json

Request:
{
  "source_embedding": [0.123, -0.456, ...],
  "target_embeddings": [
    {"id": "worker_001", "embedding": [...]},
    {"id": "worker_002", "embedding": [...]}
  ],
  "threshold": 0.8
}

Response:
{
  "success": true,
  "matches": [
    {
      "id": "worker_001",
      "similarity": 0.92,
      "matched": true
    }
  ],
  "best_match": {
    "id": "worker_001",
    "similarity": 0.92
  }
}
```

#### 11.1.3 연동 시나리오
1. **등록 시나리오**
   - 노무자가 앱에서 얼굴 사진 촬영
   - SmartCON 서버에서 FaceNet API 호출
   - 임베딩 벡터 수신 후 DB 저장

2. **인식 시나리오**
   - 현장 안면인식기에서 얼굴 감지
   - 실시간 임베딩 생성
   - 활성 리스트와 매칭 수행
   - 결과를 SmartCON 서버로 전송

### 11.2 기상청 날씨 API
#### 11.2.1 연동 개요
공사일보 작성 시 현장 위치 기반 날씨 정보를 자동으로 수집합니다.

#### 11.2.2 API 명세
**[WEATHER-API-01] 현재 날씨 조회**
```http
GET /api/v1/weather/current
Parameters:
- lat: 위도 (37.5665)
- lon: 경도 (126.9780)
- appid: API 키

Response:
{
  "weather": [
    {
      "main": "Clear",
      "description": "맑음",
      "icon": "01d"
    }
  ],
  "main": {
    "temp": 15.2,
    "feels_like": 13.8,
    "humidity": 65
  },
  "wind": {
    "speed": 2.1,
    "deg": 180
  }
}
```

#### 11.2.3 연동 시나리오
1. **일보 작성 시**
   - 현장 GPS 좌표 기반 날씨 조회
   - 온도, 습도, 풍속, 날씨 상태 자동 입력
   - 작업 가능 여부 판단 (우천, 강풍 등)

2. **배치 수집**
   - 매일 오전 6시 전국 현장 날씨 수집
   - 일보 작성 시 캐시된 데이터 사용
   - 실시간 업데이트 필요 시 API 재호출

### 11.3 PG사 결제 시스템
#### 11.3.1 연동 개요
구독 결제 및 자동 결제를 위한 PG사 API 연동입니다.

#### 11.3.2 API 명세
**[PAYMENT-API-01] 결제 요청**
```http
POST /api/v1/payment/request
Content-Type: application/json

Request:
{
  "merchant_id": "smartcon_001",
  "order_id": "SUB_20251223_001",
  "amount": 50000,
  "currency": "KRW",
  "product_name": "SmartCON Lite 프리미엄",
  "customer": {
    "name": "홍길동",
    "email": "hong@example.com",
    "phone": "010-1234-5678"
  },
  "return_url": "https://smartcon.com/payment/callback"
}

Response:
{
  "success": true,
  "payment_id": "PAY_20251223_001",
  "redirect_url": "https://pg.example.com/payment/...",
  "expires_at": "2025-12-23T15:30:00Z"
}
```

**[PAYMENT-API-02] 자동 결제**
```http
POST /api/v1/payment/subscription
Content-Type: application/json

Request:
{
  "subscription_id": "SUB_001",
  "billing_key": "BK_20251223_001",
  "amount": 50000,
  "schedule_date": "2026-01-23"
}

Response:
{
  "success": true,
  "payment_id": "PAY_20260123_001",
  "status": "SUCCESS",
  "paid_at": "2026-01-23T09:00:00Z"
}
```

### 11.4 홈택스 세금계산서 API
#### 11.4.1 연동 개요
매월 자동으로 세금계산서를 발행하고 국세청에 전송합니다.

#### 11.4.2 API 명세
**[TAX-API-01] 세금계산서 발행**
```http
POST /api/v1/tax/invoice/issue
Content-Type: application/json

Request:
{
  "supplier": {
    "business_no": "123-45-67890",
    "company_name": "주식회사 스마트콘",
    "ceo_name": "김대표",
    "address": "서울시 강남구..."
  },
  "buyer": {
    "business_no": "098-76-54321",
    "company_name": "ABC건설",
    "ceo_name": "이사장"
  },
  "items": [
    {
      "name": "SmartCON Lite 이용료",
      "quantity": 1,
      "unit_price": 45455,
      "supply_amount": 45455,
      "tax_amount": 4545
    }
  ],
  "total_amount": 50000,
  "issue_date": "2025-12-23"
}

Response:
{
  "success": true,
  "invoice_id": "INV_20251223_001",
  "nts_confirm_num": "20251223-12345678",
  "status": "ISSUED"
}
```

#### 11.4.3 연동 시나리오
1. **월간 자동 발행**
   - 매월 1일 오전 9시 배치 실행
   - 전월 구독 고객 대상 세금계산서 생성
   - 홈택스 API를 통한 자동 전송

2. **실패 처리**
   - 발행 실패 시 재시도 (최대 3회)
   - 슈퍼 관리자에게 실패 알림
   - 수동 재발행 기능 제공
---

## 12. 데이터 모델 및 API 설계

### 12.1 핵심 엔티티 모델
#### 12.1.1 사용자 및 권한 관련

**[Entity] User (사용자)**
```java
@Entity
@Table(name = "users")
public class User extends BaseTenantEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, unique = true)
    private String email;
    
    @Column(nullable = false)
    private String name;
    
    @Column(name = "phone_number")
    private String phoneNumber;
    
    @Enumerated(EnumType.STRING)
    private AuthProvider provider; // LOCAL, KAKAO, NAVER
    
    @Column(name = "provider_id")
    private String providerId;
    
    @ElementCollection(fetch = FetchType.EAGER)
    @Enumerated(EnumType.STRING)
    private Set<Role> roles = new HashSet<>();
    
    @Column(name = "is_active")
    private Boolean isActive = true;
    
    @Column(name = "last_login_at")
    private LocalDateTime lastLoginAt;
}
```

**[Entity] Tenant (테넌트/회사)**
```java
@Entity
@Table(name = "tenants")
public class Tenant extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "business_number", nullable = false, unique = true)
    private String businessNumber;
    
    @Column(name = "company_name", nullable = false)
    private String companyName;
    
    @Column(name = "ceo_name")
    private String ceoName;
    
    @Column(name = "business_type")
    private String businessType;
    
    @Embedded
    private Address address;
    
    @Enumerated(EnumType.STRING)
    private TenantStatus status; // TRIAL, ACTIVE, SUSPENDED, TERMINATED
    
    @Column(name = "subscription_plan")
    private String subscriptionPlan;
    
    @Column(name = "max_sites")
    private Integer maxSites;
    
    @Column(name = "max_users")
    private Integer maxUsers;
    
    // 구독 관련 필드 추가
    @Column(name = "subscription_start_date")
    private LocalDate subscriptionStartDate;
    
    @Column(name = "subscription_end_date")
    private LocalDate subscriptionEndDate;
    
    @Column(name = "next_billing_date")
    private LocalDate nextBillingDate;
    
    @Column(name = "monthly_price")
    private BigDecimal monthlyPrice;
    
    @Column(name = "auto_renewal")
    private Boolean autoRenewal = true;
    
    @Column(name = "billing_email")
    private String billingEmail;
}
```

**[Entity] SubscriptionPlan (구독 요금제)**
```java
@Entity
@Table(name = "subscription_plans")
public class SubscriptionPlan extends BaseEntity {
    @Id
    private String id; // basic, standard, premium, enterprise
    
    @Column(nullable = false)
    private String name;
    
    @Column(columnDefinition = "TEXT")
    private String description;
    
    @Column(name = "monthly_price", nullable = false)
    private BigDecimal monthlyPrice;
    
    @Column(name = "yearly_price")
    private BigDecimal yearlyPrice;
    
    @Column(name = "max_sites", nullable = false)
    private Integer maxSites;
    
    @Column(name = "max_users", nullable = false)
    private Integer maxUsers;
    
    @Column(name = "max_storage_gb")
    private Integer maxStorageGb;
    
    @ElementCollection
    @CollectionTable(name = "plan_features")
    private List<String> features = new ArrayList<>();
    
    @Column(name = "is_active")
    private Boolean isActive = true;
    
    @Column(name = "sort_order")
    private Integer sortOrder = 0;
}
```

**[Entity] Subscription (구독)**
```java
@Entity
@Table(name = "subscriptions")
public class Subscription extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "tenant_id", nullable = false)
    private Tenant tenant;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "plan_id", nullable = false)
    private SubscriptionPlan plan;
    
    @Enumerated(EnumType.STRING)
    private SubscriptionStatus status; // ACTIVE, SUSPENDED, CANCELLED, EXPIRED
    
    @Column(name = "start_date", nullable = false)
    private LocalDate startDate;
    
    @Column(name = "end_date")
    private LocalDate endDate;
    
    @Column(name = "next_billing_date")
    private LocalDate nextBillingDate;
    
    @Enumerated(EnumType.STRING)
    private BillingCycle billingCycle; // MONTHLY, YEARLY
    
    @Column(name = "monthly_price")
    private BigDecimal monthlyPrice;
    
    @Column(name = "discount_rate")
    private BigDecimal discountRate = BigDecimal.ZERO;
    
    @Column(name = "auto_renewal")
    private Boolean autoRenewal = true;
    
    @Column(name = "trial_end_date")
    private LocalDate trialEndDate;
    
    @Column(name = "cancellation_date")
    private LocalDate cancellationDate;
    
    @Column(name = "cancellation_reason")
    private String cancellationReason;
}
```

**[Entity] PaymentMethod (결제 수단)**
```java
@Entity
@Table(name = "payment_methods")
public class PaymentMethod extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "tenant_id", nullable = false)
    private Tenant tenant;
    
    @Enumerated(EnumType.STRING)
    private PaymentType type; // CARD, BANK_TRANSFER, VIRTUAL_ACCOUNT
    
    @Column(name = "card_number_masked")
    private String cardNumberMasked; // 1234-****-****-5678
    
    @Column(name = "card_holder_name")
    private String cardHolderName;
    
    @Column(name = "expiry_date")
    private String expiryDate; // MM/YY
    
    @Column(name = "bank_name")
    private String bankName;
    
    @Column(name = "account_number_masked")
    private String accountNumberMasked;
    
    @Column(name = "account_holder_name")
    private String accountHolderName;
    
    @Column(name = "billing_key")
    private String billingKey; // PG사 자동결제 키
    
    @Column(name = "is_default")
    private Boolean isDefault = false;
    
    @Column(name = "is_active")
    private Boolean isActive = true;
    
    @Column(name = "last_used_at")
    private LocalDateTime lastUsedAt;
}
```

**[Entity] Payment (결제 내역)**
```java
@Entity
@Table(name = "payments")
public class Payment extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "tenant_id", nullable = false)
    private Tenant tenant;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "subscription_id", nullable = false)
    private Subscription subscription;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "payment_method_id")
    private PaymentMethod paymentMethod;
    
    @Column(name = "payment_key", unique = true)
    private String paymentKey; // PG사 결제 키
    
    @Column(name = "order_id", unique = true)
    private String orderId;
    
    @Column(name = "amount", nullable = false)
    private BigDecimal amount;
    
    @Column(name = "discount_amount")
    private BigDecimal discountAmount = BigDecimal.ZERO;
    
    @Column(name = "tax_amount")
    private BigDecimal taxAmount;
    
    @Enumerated(EnumType.STRING)
    private PaymentStatus status; // PENDING, SUCCESS, FAILED, CANCELLED, REFUNDED
    
    @Column(name = "billing_period_start")
    private LocalDate billingPeriodStart;
    
    @Column(name = "billing_period_end")
    private LocalDate billingPeriodEnd;
    
    @Column(name = "paid_at")
    private LocalDateTime paidAt;
    
    @Column(name = "failed_reason")
    private String failedReason;
    
    @Column(name = "pg_response", columnDefinition = "TEXT")
    private String pgResponse; // PG사 응답 JSON
    
    @Column(name = "invoice_number")
    private String invoiceNumber;
    
    @Column(name = "tax_invoice_issued")
    private Boolean taxInvoiceIssued = false;
}
```

#### 12.1.2 현장 및 작업 관련

**[Entity] Site (현장)**
```java
@Entity
@Table(name = "sites")
public class Site extends BaseTenantEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    @Column(name = "project_name")
    private String projectName;
    
    @Embedded
    private Address address;
    
    @Column(name = "start_date")
    private LocalDate startDate;
    
    @Column(name = "end_date")
    private LocalDate endDate;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "manager_id")
    private User manager;
    
    @Enumerated(EnumType.STRING)
    private SiteStatus status; // ACTIVE, PAUSED, COMPLETED
    
    @Column(name = "face_device_serial")
    private String faceDeviceSerial;
    
    @Column(name = "work_start_time")
    private LocalTime workStartTime = LocalTime.of(8, 0);
    
    @Column(name = "work_end_time")
    private LocalTime workEndTime = LocalTime.of(18, 0);
}
```

**[Entity] WorkAssignment (작업 배정)**
```java
@Entity
@Table(name = "work_assignments")
public class WorkAssignment extends BaseTenantEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "site_id", nullable = false)
    private Site site;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "team_id", nullable = false)
    private Team team;
    
    @Column(name = "work_date", nullable = false)
    private LocalDate workDate;
    
    @Column(name = "work_type", nullable = false)
    private String workType;
    
    @Column(name = "work_location")
    private String workLocation;
    
    @Column(name = "required_workers")
    private Integer requiredWorkers;
    
    @Column(name = "assigned_workers")
    private Integer assignedWorkers;
    
    @Enumerated(EnumType.STRING)
    private AssignmentStatus status; // REQUESTED, VIEWED, ACCEPTED, REJECTED, APPROVED
    
    @Column(name = "hourly_rate")
    private BigDecimal hourlyRate;
    
    @Column(columnDefinition = "TEXT")
    private String description;
    
    @Column(name = "response_deadline")
    private LocalDateTime responseDeadline;
    
    @Column(name = "requested_at")
    private LocalDateTime requestedAt;
    
    @Column(name = "responded_at")
    private LocalDateTime respondedAt;
}
```

#### 12.1.3 출역 및 계약 관련

**[Entity] AttendanceLog (출역 기록)**
```java
@Entity
@Table(name = "attendance_logs")
public class AttendanceLog extends BaseTenantEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "worker_id", nullable = false)
    private User worker;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "site_id", nullable = false)
    private Site site;
    
    @Column(name = "work_date", nullable = false)
    private LocalDate workDate;
    
    @Column(name = "check_in_time")
    private LocalDateTime checkInTime;
    
    @Column(name = "check_out_time")
    private LocalDateTime checkOutTime;
    
    @Column(name = "total_hours")
    private BigDecimal totalHours;
    
    @Column(name = "overtime_hours")
    private BigDecimal overtimeHours;
    
    @Column(name = "face_matched")
    private Boolean faceMatched = false;
    
    @Column(name = "face_confidence")
    private BigDecimal faceConfidence;
    
    @Column(name = "gps_latitude")
    private BigDecimal gpsLatitude;
    
    @Column(name = "gps_longitude")
    private BigDecimal gpsLongitude;
    
    @Enumerated(EnumType.STRING)
    private AttendanceStatus status; // PENDING, CONFIRMED, FINALIZED
    
    @Column(name = "manual_adjustment")
    private Boolean manualAdjustment = false;
    
    @Column(name = "adjustment_reason")
    private String adjustmentReason;
}
```

**[Entity] Contract (계약서)**
```java
@Entity
@Table(name = "contracts")
public class Contract extends BaseTenantEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "worker_id", nullable = false)
    private User worker;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "site_id", nullable = false)
    private Site site;
    
    @Enumerated(EnumType.STRING)
    private ContractType type; // LABOR, SAFETY, PRIVACY
    
    @Column(name = "template_id")
    private String templateId;
    
    @Column(name = "contract_start_date")
    private LocalDate contractStartDate;
    
    @Column(name = "contract_end_date")
    private LocalDate contractEndDate;
    
    @Column(name = "daily_wage")
    private BigDecimal dailyWage;
    
    @Column(name = "work_hours")
    private Integer workHours = 8;
    
    @Enumerated(EnumType.STRING)
    private ContractStatus status; // DRAFT, PENDING_SIGNATURE, SIGNED, EXPIRED
    
    @Column(name = "pdf_url")
    private String pdfUrl;
    
    @Column(name = "signature_data", columnDefinition = "TEXT")
    private String signatureData;
    
    @Column(name = "signature_hash")
    private String signatureHash;
    
    @Column(name = "signed_at")
    private LocalDateTime signedAt;
    
    @Column(name = "signature_location")
    private String signatureLocation; // GPS 좌표
}
```

### 12.2 REST API 설계 원칙
#### 12.2.1 URL 구조
```
/api/v1/{domain}/{resource}[/{id}][/{sub-resource}]

예시:
- GET /api/v1/sites - 현장 목록 조회
- GET /api/v1/sites/123 - 특정 현장 조회
- GET /api/v1/sites/123/workers - 현장 소속 노무자 목록
- POST /api/v1/attendance/logs - 출역 기록 생성
- PUT /api/v1/contracts/456/sign - 계약서 서명
```

#### 12.2.2 HTTP 메서드 사용 규칙
| 메서드 | 용도 | 예시 |
|--------|------|------|
| GET | 조회 | GET /api/v1/sites |
| POST | 생성 | POST /api/v1/sites |
| PUT | 전체 수정 | PUT /api/v1/sites/123 |
| PATCH | 부분 수정 | PATCH /api/v1/sites/123/status |
| DELETE | 삭제 | DELETE /api/v1/sites/123 |

#### 12.2.3 응답 형식 표준화
**[성공 응답]**
```json
{
  "success": true,
  "data": {
    // 실제 데이터
  },
  "message": "요청이 성공적으로 처리되었습니다.",
  "timestamp": "2025-12-23T10:30:00Z"
}
```

**[페이징 응답]**
```json
{
  "success": true,
  "data": {
    "content": [...],
    "page": {
      "number": 0,
      "size": 20,
      "totalElements": 150,
      "totalPages": 8
    }
  }
}
```

**[오류 응답]**
```json
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "입력 데이터가 올바르지 않습니다.",
    "details": [
      {
        "field": "email",
        "message": "이메일 형식이 올바르지 않습니다."
      }
    ]
  },
  "timestamp": "2025-12-23T10:30:00Z"
}
```

### 12.3 주요 API 엔드포인트
#### 12.3.1 인증 관련 API
```http
# 로그인
POST /api/v1/auth/login
{
  "type": "HQ|SOCIAL",
  "username": "123-45-67890",
  "password": "password123",
  "provider": "KAKAO|NAVER",
  "token": "social_access_token"
}

# 토큰 갱신
POST /api/v1/auth/refresh
{
  "refreshToken": "refresh_token_here"
}

# 로그아웃
POST /api/v1/auth/logout
{
  "refreshToken": "refresh_token_here"
}

# 사용자 정보 조회
GET /api/v1/auth/me
```

#### 12.3.2 구독 관리 API
```http
# 요금제 목록 조회
GET /api/v1/subscription/plans
{
  "success": true,
  "data": [
    {
      "id": "basic",
      "name": "Basic",
      "monthlyPrice": 50000,
      "maxSites": 3,
      "maxUsers": 50,
      "features": ["기본 출역 관리", "간단 일보"]
    },
    {
      "id": "standard", 
      "name": "Standard",
      "monthlyPrice": 100000,
      "maxSites": 10,
      "maxUsers": 200,
      "features": ["고급 출역 관리", "상세 일보", "안면인식"]
    }
  ]
}

# 구독 신청
POST /api/v1/subscription/subscribe
{
  "planId": "standard",
  "paymentMethod": {
    "type": "CARD",
    "cardNumber": "1234-5678-9012-3456",
    "expiryDate": "12/27",
    "holderName": "홍길동"
  },
  "billingInfo": {
    "companyName": "ABC건설",
    "businessNumber": "123-45-67890",
    "email": "billing@abc.com"
  }
}

# 현재 구독 정보 조회
GET /api/v1/subscription/current
{
  "success": true,
  "data": {
    "planId": "standard",
    "planName": "Standard",
    "monthlyPrice": 100000,
    "status": "ACTIVE",
    "nextBillingDate": "2026-01-23",
    "usage": {
      "sites": 5,
      "maxSites": 10,
      "users": 120,
      "maxUsers": 200
    }
  }
}

# 구독 변경
PUT /api/v1/subscription/change-plan
{
  "newPlanId": "premium",
  "effectiveDate": "IMMEDIATE|NEXT_BILLING",
  "reason": "현장 확장으로 인한 업그레이드"
}

# 사용량 현황 조회
GET /api/v1/subscription/usage?period=monthly
{
  "success": true,
  "data": {
    "currentPeriod": "2025-12",
    "usage": {
      "sites": 5,
      "maxSites": 10,
      "siteUsageRate": 50,
      "users": 120,
      "maxUsers": 200,
      "userUsageRate": 60
    },
    "monthlyTrend": [
      {"month": "2025-10", "sites": 3, "users": 80},
      {"month": "2025-11", "sites": 4, "users": 100},
      {"month": "2025-12", "sites": 5, "users": 120}
    ]
  }
}

# 결제 내역 조회
GET /api/v1/subscription/payments?page=0&size=12
{
  "success": true,
  "data": {
    "content": [
      {
        "id": "PAY_20251223_001",
        "amount": 100000,
        "status": "SUCCESS",
        "paidAt": "2025-12-23T09:00:00Z",
        "period": "2025-12",
        "invoiceUrl": "/invoices/INV_20251223_001.pdf"
      }
    ],
    "page": {
      "number": 0,
      "size": 12,
      "totalElements": 24
    }
  }
}

# 결제 수단 관리
PUT /api/v1/subscription/payment-method
{
  "type": "CARD",
  "cardNumber": "9876-5432-1098-7654",
  "expiryDate": "06/28",
  "holderName": "김대표"
}

# 구독 해지 신청
POST /api/v1/subscription/cancel
{
  "reason": "서비스 불만족",
  "cancelDate": "2026-01-31",
  "feedback": "기능이 부족합니다"
}
```

#### 12.3.3 현장 관리 API
```http
# 현장 목록 조회
GET /api/v1/sites?page=0&size=20&status=ACTIVE

# 현장 생성
POST /api/v1/sites
{
  "name": "강남 아파트 신축공사",
  "projectName": "강남 래미안 아파트",
  "address": {
    "roadAddress": "서울시 강남구 테헤란로 123",
    "detailAddress": "지하 1층",
    "zipCode": "06234"
  },
  "startDate": "2025-01-01",
  "endDate": "2025-12-31",
  "managerId": 123
}

# 현장 수정
PUT /api/v1/sites/123
{
  "name": "강남 아파트 신축공사 (수정)",
  "endDate": "2026-06-30"
}

# 현장 상태 변경
PATCH /api/v1/sites/123/status
{
  "status": "PAUSED",
  "reason": "우천으로 인한 작업 중단"
}
```

#### 12.3.4 작업 배정 API
```http
# 작업 요청 생성
POST /api/v1/work-assignments
{
  "siteId": 123,
  "teamId": 456,
  "workDate": "2025-12-24",
  "workType": "콘크리트공",
  "workLocation": "지하 1층",
  "requiredWorkers": 5,
  "hourlyRate": 25000,
  "description": "지하 1층 콘크리트 타설 작업",
  "responseDeadline": "2025-12-23T18:00:00Z"
}

# 작업 요청 응답 (팀장)
PATCH /api/v1/work-assignments/789/respond
{
  "response": "ACCEPTED|REJECTED",
  "assignedWorkers": 4,
  "workerIds": [101, 102, 103, 104],
  "message": "1명 부족하지만 최선을 다하겠습니다."
}

# 작업 배정 승인 (현장 관리자)
PATCH /api/v1/work-assignments/789/approve
{
  "approved": true,
  "finalWorkers": 4,
  "approvalMessage": "승인되었습니다."
}
```

#### 12.3.5 출역 관리 API
```http
# 출역 기록 조회
GET /api/v1/attendance/logs?siteId=123&date=2025-12-23

# 출역 기록 생성 (안면인식기에서 호출)
POST /api/v1/attendance/logs
{
  "workerId": 456,
  "siteId": 123,
  "checkInTime": "2025-12-23T08:15:00Z",
  "faceMatched": true,
  "faceConfidence": 0.95,
  "gpsLatitude": 37.5665,
  "gpsLongitude": 126.9780
}

# 출역 수동 보정
PATCH /api/v1/attendance/logs/789/adjust
{
  "checkInTime": "2025-12-23T08:00:00Z",
  "checkOutTime": "2025-12-23T18:00:00Z",
  "reason": "안면인식 실패로 인한 수동 처리"
}

# 일일 출역 마감
POST /api/v1/attendance/finalize
{
  "siteId": 123,
  "date": "2025-12-23",
  "logIds": [789, 790, 791]
}
```

#### 12.3.6 계약 관리 API
```http
# 계약서 목록 조회
GET /api/v1/contracts?workerId=456&status=PENDING_SIGNATURE

# 계약서 생성
POST /api/v1/contracts
{
  "workerId": 456,
  "siteId": 123,
  "type": "LABOR",
  "templateId": "STD_LABOR_2025",
  "contractStartDate": "2025-01-01",
  "contractEndDate": "2025-12-31",
  "dailyWage": 200000,
  "workHours": 8
}

# 계약서 서명
PUT /api/v1/contracts/789/sign
{
  "signatureData": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAA...",
  "signatureLocation": "37.5665,126.9780"
}

# 계약서 PDF 다운로드
GET /api/v1/contracts/789/pdf
```

---

## 13. 보안 및 성능 요구사항

### 13.1 보안 요구사항
#### 13.1.1 인증 및 인가
- **JWT 토큰**: Access Token (15분), Refresh Token (7일)
- **토큰 저장**: HttpOnly Cookie 또는 Secure Storage
- **권한 검증**: 모든 API 요청에 대한 역할 기반 권한 확인
- **세션 관리**: 동시 로그인 제한 (최대 3개 디바이스)

#### 13.1.2 데이터 보안
- **개인정보 암호화**: AES-256 암호화 (주민번호, 계좌번호)
- **데이터 마스킹**: 화면 표시 시 민감정보 마스킹
- **전송 암호화**: HTTPS 강제, TLS 1.3 이상
- **데이터베이스**: 컬럼 레벨 암호화, 접근 로그 기록

#### 13.1.3 API 보안
- **Rate Limiting**: IP당 분당 100회 제한
- **CORS 설정**: 허용된 도메인만 접근 가능
- **SQL Injection 방지**: Prepared Statement 사용
- **XSS 방지**: 입력 데이터 검증 및 이스케이프

### 13.2 성능 요구사항
#### 13.2.1 응답 시간
- **API 응답**: 평균 200ms 이하, 95% 1초 이하
- **페이지 로딩**: 초기 로딩 3초 이하
- **안면인식**: 1초 이내 인식 완료
- **파일 업로드**: 10MB 파일 30초 이내

#### 13.2.2 동시 사용자
- **동시 접속**: 1,000명 이상
- **피크 시간**: 오전 8시, 오후 6시 (출퇴근 시간)
- **데이터베이스**: 초당 1,000 TPS 처리
- **파일 저장소**: 동시 100개 파일 업로드

#### 13.2.3 가용성
- **서비스 가동률**: 99.9% 이상 (월 43분 이하 다운타임)
- **데이터 백업**: 일일 자동 백업, 실시간 복제
- **장애 복구**: RTO 1시간, RPO 15분
- **모니터링**: 24/7 시스템 모니터링

### 13.3 확장성 요구사항
#### 13.3.1 수평 확장
- **애플리케이션**: 로드 밸런서 기반 다중 인스턴스
- **데이터베이스**: Read Replica 구성
- **파일 저장소**: CDN 연동으로 전역 배포
- **캐시**: Redis Cluster 구성

#### 13.3.2 수직 확장
- **서버 스펙**: CPU 8코어, 메모리 16GB 이상
- **데이터베이스**: SSD 스토리지, 충분한 IOPS
- **네트워크**: 1Gbps 이상 대역폭
- **모니터링**: 리소스 사용률 실시간 모니터링

---

## 14. 테스트 시나리오 및 검증 기준

### 14.1 단위 테스트 (Unit Test)
#### 14.1.1 백엔드 테스트
```java
// 예시: 출역 시간 계산 테스트
@Test
void calculateWorkingHours_정상케이스() {
    // Given
    LocalDateTime checkIn = LocalDateTime.of(2025, 12, 23, 8, 0);
    LocalDateTime checkOut = LocalDateTime.of(2025, 12, 23, 18, 0);
    
    // When
    WorkingHours result = attendanceService.calculateWorkingHours(checkIn, checkOut);
    
    // Then
    assertThat(result.getTotalHours()).isEqualTo(BigDecimal.valueOf(10.0));
    assertThat(result.getRegularHours()).isEqualTo(BigDecimal.valueOf(8.0));
    assertThat(result.getOvertimeHours()).isEqualTo(BigDecimal.valueOf(2.0));
}

@Test
void calculateWorkingHours_점심시간제외() {
    // Given
    LocalDateTime checkIn = LocalDateTime.of(2025, 12, 23, 8, 0);
    LocalDateTime checkOut = LocalDateTime.of(2025, 12, 23, 18, 0);
    
    // When
    WorkingHours result = attendanceService.calculateWorkingHours(checkIn, checkOut, true);
    
    // Then
    assertThat(result.getTotalHours()).isEqualTo(BigDecimal.valueOf(9.0)); // 점심시간 1시간 제외
}
```

#### 14.1.2 프론트엔드 테스트
```typescript
// 예시: 로그인 폼 검증 테스트
describe('LoginForm', () => {
  test('사업자번호 형식 검증', () => {
    render(<LoginForm />);
    
    const businessNumberInput = screen.getByLabelText('사업자번호');
    fireEvent.change(businessNumberInput, { target: { value: '1234567890' } });
    
    expect(businessNumberInput.value).toBe('123-45-67890'); // 자동 하이픈 삽입
  });
  
  test('로그인 실패 시 오류 메시지 표시', async () => {
    const mockLogin = jest.fn().mockRejectedValue(new Error('로그인 실패'));
    
    render(<LoginForm onLogin={mockLogin} />);
    
    fireEvent.click(screen.getByText('로그인'));
    
    await waitFor(() => {
      expect(screen.getByText('로그인에 실패했습니다.')).toBeInTheDocument();
    });
  });
});
```

### 14.2 통합 테스트 (Integration Test)
#### 14.2.1 API 통합 테스트
```java
@SpringBootTest
@AutoConfigureTestDatabase
class SiteControllerIntegrationTest {
    
    @Test
    @WithMockUser(roles = "HQ")
    void createSite_성공() throws Exception {
        // Given
        CreateSiteRequest request = CreateSiteRequest.builder()
            .name("테스트 현장")
            .projectName("테스트 프로젝트")
            .startDate(LocalDate.now())
            .endDate(LocalDate.now().plusMonths(6))
            .build();
        
        // When & Then
        mockMvc.perform(post("/api/v1/sites")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.success").value(true))
            .andExpect(jsonPath("$.data.name").value("테스트 현장"));
    }
    
    @Test
    @WithMockUser(roles = "WORKER")
    void createSite_권한없음() throws Exception {
        // When & Then
        mockMvc.perform(post("/api/v1/sites")
                .contentType(MediaType.APPLICATION_JSON)
                .content("{}"))
            .andExpect(status().isForbidden());
    }
}
```

### 14.3 E2E 테스트 (End-to-End Test)
#### 14.3.1 사용자 시나리오 테스트
```typescript
// 예시: Playwright를 사용한 E2E 테스트
test('현장 관리자 작업 배정 시나리오', async ({ page }) => {
  // 1. 로그인
  await page.goto('/login');
  await page.click('text=소셜 로그인');
  await page.click('text=카카오 로그인');
  // ... 소셜 로그인 처리
  
  // 2. 현장 선택
  await page.click('text=강남 아파트 현장');
  await expect(page).toHaveURL('/site/dashboard');
  
  // 3. 작업 배정 생성
  await page.click('text=작업 배정');
  await page.fill('[name="workType"]', '콘크리트공');
  await page.fill('[name="requiredWorkers"]', '5');
  await page.click('text=팀 선택');
  await page.click('text=김팀장 팀');
  await page.click('text=요청 발송');
  
  // 4. 요청 발송 확인
  await expect(page.locator('text=작업 요청이 발송되었습니다')).toBeVisible();
  
  // 5. 요청 상태 확인
  await page.click('text=요청 현황');
  await expect(page.locator('text=발송됨')).toBeVisible();
});
```

### 14.4 성능 테스트
#### 14.4.1 부하 테스트 시나리오
```javascript
// 예시: K6를 사용한 부하 테스트
import http from 'k6/http';
import { check, sleep } from 'k6';

export let options = {
  stages: [
    { duration: '2m', target: 100 }, // 2분간 100명까지 증가
    { duration: '5m', target: 100 }, // 5분간 100명 유지
    { duration: '2m', target: 200 }, // 2분간 200명까지 증가
    { duration: '5m', target: 200 }, // 5분간 200명 유지
    { duration: '2m', target: 0 },   // 2분간 0명까지 감소
  ],
};

export default function () {
  // 로그인
  let loginResponse = http.post('https://api.smartcon.com/api/v1/auth/login', {
    type: 'SOCIAL',
    provider: 'KAKAO',
    token: 'test_token'
  });
  
  check(loginResponse, {
    '로그인 성공': (r) => r.status === 200,
    '응답 시간 < 500ms': (r) => r.timings.duration < 500,
  });
  
  let accessToken = loginResponse.json('data.accessToken');
  
  // 현장 목록 조회
  let sitesResponse = http.get('https://api.smartcon.com/api/v1/sites', {
    headers: { Authorization: `Bearer ${accessToken}` },
  });
  
  check(sitesResponse, {
    '현장 목록 조회 성공': (r) => r.status === 200,
    '응답 시간 < 200ms': (r) => r.timings.duration < 200,
  });
  
  sleep(1);
}
```

### 14.5 보안 테스트
#### 14.5.1 취약점 검증 시나리오
```bash
# SQL Injection 테스트
curl -X GET "https://api.smartcon.com/api/v1/sites?name='; DROP TABLE sites; --"

# XSS 테스트
curl -X POST "https://api.smartcon.com/api/v1/sites" \
  -H "Content-Type: application/json" \
  -d '{"name": "<script>alert(\"XSS\")</script>"}'

# 권한 우회 테스트
curl -X DELETE "https://api.smartcon.com/api/v1/sites/123" \
  -H "Authorization: Bearer worker_token"

# Rate Limiting 테스트
for i in {1..200}; do
  curl -X GET "https://api.smartcon.com/api/v1/sites" &
done
```

---

## 15. 배포 및 운영 가이드

### 15.1 개발 환경 설정
#### 15.1.1 로컬 개발 환경
```bash
# 1. 저장소 클론
git clone https://github.com/company/smartcon-lite.git
cd smartcon-lite

# 2. 백엔드 설정
cd backend
cp application-local.yml.example application-local.yml
# 데이터베이스 및 외부 API 설정 수정

# 3. 데이터베이스 실행 (Docker)
docker-compose up -d mariadb redis

# 4. 백엔드 실행
mvn spring-boot:run -Dspring.profiles.active=local

# 5. 프론트엔드 설정
cd ../prototype
npm install
cp .env.local.example .env.local
# API 엔드포인트 설정 수정

# 6. 프론트엔드 실행
npm run dev
```

#### 15.1.2 Docker 개발 환경
```yaml
# docker-compose.dev.yml
version: '3.8'
services:
  mariadb:
    image: mariadb:10.11
    environment:
      MYSQL_ROOT_PASSWORD: smartcon123
      MYSQL_DATABASE: smartcon_dev
    ports:
      - "3306:3306"
    volumes:
      - mariadb_data:/var/lib/mysql

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile.dev
    ports:
      - "8080:8080"
    environment:
      SPRING_PROFILES_ACTIVE: docker
      DB_HOST: mariadb
      REDIS_HOST: redis
    depends_on:
      - mariadb
      - redis

  frontend:
    build:
      context: ./prototype
      dockerfile: Dockerfile.dev
    ports:
      - "5173:5173"
    environment:
      VITE_API_URL: http://localhost:8080
    volumes:
      - ./prototype/src:/app/src

volumes:
  mariadb_data:
```

### 15.2 프로덕션 배포
#### 15.2.1 CI/CD 파이프라인 (GitHub Actions)
```yaml
# .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
      
      - name: Run backend tests
        run: |
          cd backend
          mvn test
      
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Run frontend tests
        run: |
          cd prototype
          npm ci
          npm run test:run

  build-and-deploy:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Build backend
        run: |
          cd backend
          mvn clean package -DskipTests
      
      - name: Build frontend
        run: |
          cd prototype
          npm ci
          npm run build
      
      - name: Build Docker images
        run: |
          docker build -t smartcon-backend:${{ github.sha }} ./backend
          docker build -t smartcon-frontend:${{ github.sha }} ./prototype
      
      - name: Deploy to AWS ECS
        run: |
          # AWS ECS 배포 스크립트
          aws ecs update-service --cluster smartcon-prod --service backend --force-new-deployment
          aws ecs update-service --cluster smartcon-prod --service frontend --force-new-deployment
```

#### 15.2.2 프로덕션 환경 설정
```yaml
# docker-compose.prod.yml
version: '3.8'
services:
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - backend
      - frontend

  backend:
    image: smartcon-backend:latest
    environment:
      SPRING_PROFILES_ACTIVE: prod
      DB_HOST: ${DB_HOST}
      DB_PASSWORD: ${DB_PASSWORD}
      JWT_SECRET: ${JWT_SECRET}
      AWS_ACCESS_KEY: ${AWS_ACCESS_KEY}
      AWS_SECRET_KEY: ${AWS_SECRET_KEY}
    deploy:
      replicas: 3
      resources:
        limits:
          memory: 2G
          cpus: '1.0'

  frontend:
    image: smartcon-frontend:latest
    environment:
      VITE_API_URL: https://api.smartcon.com
    deploy:
      replicas: 2

  mariadb:
    image: mariadb:10.11
    environment:
      MYSQL_ROOT_PASSWORD: ${DB_ROOT_PASSWORD}
      MYSQL_DATABASE: smartcon_prod
    volumes:
      - mariadb_prod_data:/var/lib/mysql
    deploy:
      replicas: 1
      placement:
        constraints:
          - node.role == manager

volumes:
  mariadb_prod_data:
    external: true
```

### 15.3 모니터링 및 로깅
#### 15.3.1 애플리케이션 모니터링
```yaml
# monitoring/docker-compose.yml
version: '3.8'
services:
  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml

  grafana:
    image: grafana/grafana
    ports:
      - "3000:3000"
    environment:
      GF_SECURITY_ADMIN_PASSWORD: admin123
    volumes:
      - grafana_data:/var/lib/grafana

  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.5.0
    environment:
      discovery.type: single-node
      xpack.security.enabled: false
    ports:
      - "9200:9200"

  kibana:
    image: docker.elastic.co/kibana/kibana:8.5.0
    ports:
      - "5601:5601"
    environment:
      ELASTICSEARCH_HOSTS: http://elasticsearch:9200

volumes:
  grafana_data:
```

#### 15.3.2 로그 설정
```yaml
# backend/src/main/resources/logback-spring.xml
<configuration>
    <springProfile name="prod">
        <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
            <encoder class="net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder">
                <providers>
                    <timestamp/>
                    <logLevel/>
                    <loggerName/>
                    <message/>
                    <mdc/>
                    <stackTrace/>
                </providers>
            </encoder>
        </appender>
        
        <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
            <file>/app/logs/smartcon.log</file>
            <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
                <fileNamePattern>/app/logs/smartcon.%d{yyyy-MM-dd}.%i.gz</fileNamePattern>
                <maxFileSize>100MB</maxFileSize>
                <maxHistory>30</maxHistory>
            </rollingPolicy>
            <encoder class="net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder">
                <providers>
                    <timestamp/>
                    <logLevel/>
                    <loggerName/>
                    <message/>
                    <mdc/>
                    <stackTrace/>
                </providers>
            </encoder>
        </appender>
        
        <root level="INFO">
            <appender-ref ref="STDOUT"/>
            <appender-ref ref="FILE"/>
        </root>
    </springProfile>
</configuration>
```

---

## 16. 결론 및 다음 단계

### 16.1 문서 요약
본 상세기능명세서는 SmartCON Lite SaaS 플랫폼의 전체 기능을 체계적으로 정의했습니다:

- **5단계 사용자 역할**별 상세 기능 명세
- **멀티테넌트 아키텍처** 기반 시스템 설계
- **안면인식, 전자계약, 정산** 등 핵심 비즈니스 프로세스
- **REST API 설계** 및 데이터 모델 정의
- **보안, 성능, 테스트** 요구사항
- **배포 및 운영** 가이드

### 16.2 개발 우선순위
실행계획에 따른 개발 우선순위는 다음과 같습니다:

**Phase 1 (1-2개월): 핵심 인프라**
- 멀티테넌트 아키텍처 구현
- 인증/인가 시스템 구축
- 기본 사용자 관리 기능

**Phase 2 (3-4개월): 기본 기능**
- 현장 및 팀 관리
- 작업 배정 시스템
- 기본 출역 관리

**Phase 3 (5-6개월): 고급 기능**
- 안면인식 연동
- 전자계약 시스템
- 공사일보 자동화

**Phase 4 (7-8개월): 비즈니스 기능**
- 정산 및 급여 계산
- 구독 결제 시스템
- 세금계산서 자동 발행

**Phase 5 (9-10개월): 최적화**
- 성능 최적화
- 모니터링 시스템
- 사용자 경험 개선

### 16.3 성공 지표 (KPI)
- **기술적 지표**: 응답시간 < 200ms, 가동률 > 99.9%
- **비즈니스 지표**: 월간 활성 사용자 1,000명, 고객 만족도 4.5/5.0
- **운영 지표**: 자동화율 90%, 장애 복구 시간 < 1시간

### 16.4 지속적 개선 계획
- **사용자 피드백** 수집 및 반영
- **성능 모니터링** 및 최적화
- **보안 취약점** 정기 점검
- **신기술 도입** 검토 (AI, 블록체인 등)

---

**문서 끝**

*본 문서는 SmartCON Lite 플랫폼 개발의 기준이 되는 상세 기능명세서입니다. 개발 과정에서 변경사항이 발생할 경우 본 문서를 업데이트하여 최신 상태를 유지해야 합니다.*